<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LCD12864串口屏通信协议</title>
    <url>/2023/08/06/LCD12865%E4%B8%B2%E5%8F%A3%E5%B1%8F/</url>
    <content><![CDATA[<p>LCD12864串口显示屏具体操作信息</p>
<a id="more"></a>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>串口波特率：9600</p>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><h3 id="字符串显示"><a href="#字符串显示" class="headerlink" title="字符串显示"></a>字符串显示</h3><p>###画点协议</p>
]]></content>
  </entry>
  <entry>
    <title>长按按钮开关机</title>
    <url>/2020/04/05/powerctrl/</url>
    <content><![CDATA[<h2 id="实现一个按键控制设备电源关断"><a href="#实现一个按键控制设备电源关断" class="headerlink" title="实现一个按键控制设备电源关断"></a>实现一个按键控制设备电源关断</h2><p>本文记录三极管继电器实现一键开关的方法<br><img src="https://ae01.alicdn.com/kf/Hb0b05277e48d4cf499ded9ab70d46de0Y.jpg" alt></p>
<a id="more"></a>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>一开始不打算用继电器的，因为想要做的设备非常小，常规的继电器替继太大，小体积继电器价格较为昂贵。因此一开始的思路是用三极管或mos管。</p>
<h2 id="二、设计思路"><a href="#二、设计思路" class="headerlink" title="二、设计思路"></a>二、设计思路</h2><p>首先这不是用纯电路完成的，当然用纯电路更好但是会相对复杂。</p>
<p>当电源键按下后，电源接通，芯片的IO检测电源键按下后进行计时，可以们设置3秒后开关机，如果不到3秒我们不做任何动作，抬起电源键设备不通电。如果到了3秒，芯片另一IO口输出电平控制电源通断，这时候我们抬起电源键，设备仍然是工作的。</p>
<h2 id="三、为什么不用三极管和MOS管"><a href="#三、为什么不用三极管和MOS管" class="headerlink" title="三、为什么不用三极管和MOS管"></a>三、为什么不用三极管和MOS管</h2><p>这一结构如果用在12V电压下使用三极管或mos管应该没问题，但是我是用在5V电压下。<br>STM32的IO口输出电压是3.3V，考虑到最大限度节约电能，三极管并未像驱动继电器一样在基极添加电阻连接集电极，但是这输出的电压却远远不够驱动单片机，电压表测量只有2V左右，而且加上显示屏，根本达不到要求，MOS管测量后和三极管基本没有太大区别，因此放弃使用。</p>
<p>后期使用可控硅效果也不太好…</p>
<h2 id="四、电路搭建"><a href="#四、电路搭建" class="headerlink" title="四、电路搭建"></a>四、电路搭建</h2><p>因为单片机输出电压是3.3V，所以选用3V继电器是最好的。<br>个人选用的松下信号继电器。<br><img src="https://s1.ax1x.com/2020/04/05/GrdFCn.jpg" alt><br>体积很小，长宽高15mm-10mm-5mm<br><img src="https://s1.ax1x.com/2020/04/05/Gr6StU.jpg" alt><br>电路是很简单了，但是相比网上使用三极管mos管组成的开关电路，继电器性能真的要高很多很多，至少在电压问题上完全不用担心。<br>配一张成功的图<br><img src="https://s1.ax1x.com/2020/04/05/GrcqZq.jpg" alt><br>上面可控硅啥的我就不拆了好麻烦。</p>
]]></content>
  </entry>
  <entry>
    <title>51FIT自制系列04最小系统板</title>
    <url>/2020/03/16/51FIT04/</url>
    <content><![CDATA[<h1 id="型号：51FIT-04-串口下载集成开发板"><a href="#型号：51FIT-04-串口下载集成开发板" class="headerlink" title="型号：51FIT_04 串口下载集成开发板"></a>型号：51FIT_04 串口下载集成开发板</h1><p>详细的使用方法以及PCB原理图<br><img src="https://ae01.alicdn.com/kf/H5da4bb57ea1f4bff919ddaea371e473c3.jpg" alt></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于许多的单片机使用者而言，或多或少都存在着一些对外围电路焊接错误等问题。51FIT系列制作的主要目的在于化繁为简，制作多模块集成的开发系统板。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>51FIT04串口下载继承开发板，主要组成为<strong>51单片机贴片</strong>和<strong>CH340T</strong>串口芯片，以达到下载程序时不需要使用串口模块频繁接线，使用普通的USB线即可下载。<br><img src="https://s1.ax1x.com/2020/03/20/8c26oD.jpg" alt></p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h3><p>只可从5V引脚和USB进行供电，3.3V为稳压输出引脚。</p>
<h3 id="程序下载"><a href="#程序下载" class="headerlink" title="程序下载"></a>程序下载</h3><p>04机并没有自动下载功能，自动下载将在后续型号的板子上增加。<br>这里我们需要手动进行复位，点击下载程序后按下RST进行断电复位，即可下载。</p>
<h3 id="板载LED"><a href="#板载LED" class="headerlink" title="板载LED"></a>板载LED</h3><p>为了将所有常用IO口引出切不受影响，这里使用P40-3引脚控制led。<br>详细使用方法：[AT89C52RC/RD系列贴片与P4管脚的使用][1]<br>[1]:<a href="https://square0097.github.io/2020/02/18/AT89C52" target="_blank" rel="noopener">https://square0097.github.io/2020/02/18/AT89C52</a></p>
<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><h3 id="51芯片"><a href="#51芯片" class="headerlink" title="51芯片"></a>51芯片</h3><p><img src="https://s1.ax1x.com/2020/03/20/8c2ZdS.jpg" alt></p>
<h3 id="51最小系统"><a href="#51最小系统" class="headerlink" title="51最小系统"></a>51最小系统</h3><p><img src="https://s1.ax1x.com/2020/03/20/8c2eIg.jpg" alt></p>
<h3 id="板载LED-1"><a href="#板载LED-1" class="headerlink" title="板载LED"></a>板载LED</h3><p><img src="https://s1.ax1x.com/2020/03/20/8c2ksP.jpg" alt></p>
<h3 id="电源指示"><a href="#电源指示" class="headerlink" title="电源指示"></a>电源指示</h3><p><img src="https://s1.ax1x.com/2020/03/20/8c2DL6.jpg" alt></p>
<h3 id="CH340T"><a href="#CH340T" class="headerlink" title="CH340T"></a>CH340T</h3><p><img src="https://s1.ax1x.com/2020/03/20/8c2Aqf.jpg" alt></p>
<h3 id="外接串口"><a href="#外接串口" class="headerlink" title="外接串口"></a>外接串口</h3><p><img src="https://s1.ax1x.com/2020/03/20/8c2FMt.jpg" alt></p>
<h3 id="AMS1117-3-3"><a href="#AMS1117-3-3" class="headerlink" title="AMS1117 3.3"></a>AMS1117 3.3</h3><p><img src="https://s1.ax1x.com/2020/03/20/8c2KRs.jpg" alt></p>
<h2 id="外形图"><a href="#外形图" class="headerlink" title="外形图"></a>外形图</h2><p><img src="https://s1.ax1x.com/2020/03/20/8c2aW9.jpg" alt><br><img src="https://s1.ax1x.com/2020/03/20/8c2Bsx.jpg" alt></p>
]]></content>
  </entry>
  <entry>
    <title>欢迎访问</title>
    <url>/2020/03/07/%E6%AC%A2%E8%BF%8E%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="訪問を歓迎します！！！"><a href="#訪問を歓迎します！！！" class="headerlink" title="訪問を歓迎します！！！"></a>訪問を歓迎します！！！</h1><p>用户可搜索关键字<br>博客新增评论功能<br><img src="https://ae01.alicdn.com/kf/H955510208f0d4cbb82b943026428f0b20.png" alt></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29722692&auto=1&height=66"></iframe>
]]></content>
  </entry>
  <entry>
    <title>COM-Ruler01自制系列集成尺</title>
    <url>/2020/03/06/comruler/</url>
    <content><![CDATA[<h1 id="型号：COM-R01无线串口51格尺集成板"><a href="#型号：COM-R01无线串口51格尺集成板" class="headerlink" title="型号：COM-R01无线串口51格尺集成板"></a>型号：COM-R01无线串口51格尺集成板</h1><p><img src="https://ae01.alicdn.com/kf/H39689e9f52c540329a6029c97d2a5213X.jpg" alt></p>
<a id="more"></a>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>有的人说这个尺子不方便用啊，焊上元件之后岂不是会很扎手？</p>
<p>如果我们真的只是需要用它来作为格尺，就不需要焊接任何元件，仅仅是作为一个板子，那还咋扎手，在学校绝对彰显你是个搞开发的！<br><img src="https://s1.ax1x.com/2020/03/21/8R9yWD.jpg" alt></p>
<p>可以应用为串口模块、2.4G遥控器，3.3V电源输出等</p>
<h2 id="二、使用说明"><a href="#二、使用说明" class="headerlink" title="二、使用说明"></a>二、使用说明</h2><h3 id="串口模块"><a href="#串口模块" class="headerlink" title="串口模块"></a>串口模块</h3><p>串口模块在右侧偏右的位置，如果我们只需要使用串口模块，就只需要焊接这部分。<br><img src="https://s1.ax1x.com/2020/03/20/8cqGcT.jpg" alt><br>这里可以直接在左侧排针和焊点上作为RXD和TXD的引脚。</p>
<p>这里power为电源指示灯。</p>
<h3 id="51单片机"><a href="#51单片机" class="headerlink" title="51单片机"></a>51单片机</h3><p>焊接贴片时注意小圆点的方向位置。<br>可以使用CH340来下载，也可使用外接串口模块从左侧排针下载<br><img src="https://s1.ax1x.com/2020/03/21/8R9we1.jpg" alt><br>download是单片机电源线上的开口，如果使用自带串口模块下载，在下载时请使用导线短接和断开进行手动下载，不要焊死。<br>使用外接下载器时焊死即可。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>晶振11.0592M</strong></p>
<pre><code>sbit k0=P0^4;
sbit k1=P0^5;
sbit k2=P0^6;
sbit k3=P0^7;
sbit led0=P1^3;
sbit led1=P1^2;
sbit led2=P1^1;
sbit led3=P1^0;</code></pre><h3 id="JDY-40和3-3V输出"><a href="#JDY-40和3-3V输出" class="headerlink" title="JDY-40和3.3V输出"></a>JDY-40和3.3V输出</h3><p>   这里默认的JDY-40波特率为9600，如需其他波特率请自行短接SET与VCC。<br>   <img src="https://s1.ax1x.com/2020/03/20/8cqnBQ.jpg" alt><br>   3.3位置为指示灯，左正右负。如果亮起则说明AMS1117正常输出3.3V。<br>   可以通过左侧3.3V输出口获得电压。<br>   同时3.3V为JDY-40提供电源。<br>   这里默认CS和GND短接，默认模块唤醒。<br>   数据传输有两个选择，接收51的串口信息则短接MCU处的焊点，接收CH340T则短接340T处焊点。<br>   这里JDY-40的侧面引脚仅起到固定作用。</p>
<h2 id="三、AD图"><a href="#三、AD图" class="headerlink" title="三、AD图"></a>三、AD图</h2><p>PCB二维和三维<br><img src="https://s1.ax1x.com/2020/03/21/8R9gQH.jpg" alt><br><img src="https://s1.ax1x.com/2020/03/21/8R9sJO.jpg" alt><br><img src="https://s1.ax1x.com/2020/03/21/8R9Uy9.jpg" alt></p>
]]></content>
  </entry>
  <entry>
    <title>如何使用VC++6.0 MFC制作串口上位机</title>
    <url>/2020/02/22/hostcomputer/</url>
    <content><![CDATA[<h2 id="VC6MFC的串口控件怎么用？编辑框显示串口信息是乱码怎么办？下拉列表没有内容怎么办？"><a href="#VC6MFC的串口控件怎么用？编辑框显示串口信息是乱码怎么办？下拉列表没有内容怎么办？" class="headerlink" title="VC6MFC的串口控件怎么用？编辑框显示串口信息是乱码怎么办？下拉列表没有内容怎么办？"></a>VC6MFC的串口控件怎么用？编辑框显示串口信息是乱码怎么办？下拉列表没有内容怎么办？</h2><p>记录上vc6位机制作过程和需要注意的问题<br><img src="https://ae01.alicdn.com/kf/Hc33b8a934a704f5e9b0f33ebe9f93568v.jpg" alt></p>
<a id="more"></a>
<h2 id="一、为什么使用VC6"><a href="#一、为什么使用VC6" class="headerlink" title="一、为什么使用VC6"></a>一、为什么使用VC6</h2><p>VC6虽然是比较老的编程软件，但是他的性能很好，功能齐全，操作简单，可以完成windows系统下很多的功能，比如串口通信，网络通信等等。现在的VS虽然比VC6性能好得多，但是低配电脑基本上很卡，不建议低配电脑使用，我就是。</p>
<h2 id="二、VC6的安装"><a href="#二、VC6的安装" class="headerlink" title="二、VC6的安装"></a>二、VC6的安装</h2><p>这里有一个<a href="https://wap.qidian.qq.com/ol/rest/view/2852150155_10207_1_1551343393?from=singlemessage" target="_blank" rel="noopener">微信上的安装教程</a></p>
<h2 id="三、MFC的工程建立和编译"><a href="#三、MFC的工程建立和编译" class="headerlink" title="三、MFC的工程建立和编译"></a>三、MFC的工程建立和编译</h2><h3 id="1、工程建立"><a href="#1、工程建立" class="headerlink" title="1、工程建立"></a>1、工程建立</h3><ul>
<li>点击文件，新建，输入工程名（注意不可以使用中文），点击<strong>MFC AppWizard[exe]</strong>后确定。<br><img src="https://s1.ax1x.com/2020/03/21/8RPTMQ.jpg" alt><br>建立基本对话框<br><img src="https://s1.ax1x.com/2020/03/21/8RP7rj.jpg" alt><br>之后会提示你工程的相关信息，确认即可。</li>
</ul>
<h3 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h3><p>编译运行和常规的方式一样。</p>
<p>如果我们想让电脑里没有安装VC6的人运行我们制作的MFC程序的话，我们需要在<strong>工程</strong>，<strong>设置</strong> 中，将<strong>使用MFC作为共享的DLL</strong>改为<strong>使用MFC作为静态链接库</strong>，这样我们就可以让其他电脑运行MFC的窗口程序，这就是在可执行文件中加入了MFC的运行库。</p>
<p>但根据情况而定，这样会让你的exe增到10MB左右。</p>
<h3 id="打开工程"><a href="#打开工程" class="headerlink" title="打开工程"></a>打开工程</h3><p>我们要注意的是打开工程一定要点击 <strong>打开工作空间</strong> ，因为点击打开会出现闪退现象！原因未知…</p>
<h2 id="四、窗口控件的使用"><a href="#四、窗口控件的使用" class="headerlink" title="四、窗口控件的使用"></a>四、窗口控件的使用</h2><h3 id="1、窗口控件的插入"><a href="#1、窗口控件的插入" class="headerlink" title="1、窗口控件的插入"></a>1、窗口控件的插入</h3><p><img src="https://s1.ax1x.com/2020/03/21/8RPHqs.jpg" alt><br>在工作区的右侧我们可以看到这样的一个工具栏，我妈可以添加需要的空间到窗口上，同样窗口上的多余内容我们可以删掉。</p>
<h3 id="2、具体的控件使用方法"><a href="#2、具体的控件使用方法" class="headerlink" title="2、具体的控件使用方法"></a>2、具体的控件使用方法</h3><p>如果你找不到你的窗口界面了，那么请打开左侧栏的<strong>ResourceView</strong>中的<strong>Dialog</strong>。</p>
<h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><p>按钮的名称在其右键属性中更改，标题即为显示的名称。</p>
<p>双击按钮，出现对话框，这里是让用户设定按钮时间函数的名称，可以默认为其ID，也可以自行设置为 <strong>“On…”</strong> 的格式。</p>
<p>命名后自动跳转到了按钮事件函数,如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CHostcomputerDlg::OnButton2() </span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; TODO: Add your control notification handler code here</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果窗口上按钮很多，命名无法找到相应函数时可以双击窗口按钮来编辑程序。</p>
<p>按钮事件函数我们可以理解成单片机中的中断函数，程序执行过程中只要按下按钮就会执行这个函数。</p>
<h4 id="静态文本和组框"><a href="#静态文本和组框" class="headerlink" title="静态文本和组框"></a>静态文本和组框</h4><p>这两个就很简单了，直接放置到窗口上，右键属性，在标题中修改要显示的内容。</p>
<h4 id="编辑框"><a href="#编辑框" class="headerlink" title="编辑框"></a>编辑框</h4><p>编辑框可以作为显示窗口使用，也可作为输入框。<br><img src="https://s1.ax1x.com/2020/03/21/8RPLaq.jpg" alt></p>
<ul>
<li>如果横向文字很多，那么可选择水平滚动，以方便查看横向，如果编辑框宽度够用那么就不用改横向的属性。</li>
<li>作为上位机我们显示数据可以是一行一行的显示，这时候就要使用垂直和自动垂直滚动，这样更新的数据就会逐行在这里显示。</li>
<li>我们可以使用类的方式也可以不使用，这里列举输入不用类，输出使用类的方式。</li>
</ul>
<h5 id="编辑框作为输入"><a href="#编辑框作为输入" class="headerlink" title="编辑框作为输入"></a>编辑框作为输入</h5><p>这里我们就要引入一种类 <strong>CString</strong>，它不是一种数据类型也不是C++中的标准库，在MFC中普遍使用，可以说是非常的方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CString str;</span><br><span class="line">GetDlgItem(IDC_EDIT1)-&gt;GetWindowText(str);</span><br></pre></td></tr></table></figure>
<p>这里的<strong>IDC_EDIT1</strong>是编辑框的ID，此时编辑框中的内容已经存到了<strong>str</strong>中。</p>
<h5 id="编辑框作为显示"><a href="#编辑框作为显示" class="headerlink" title="编辑框作为显示"></a>编辑框作为显示</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m_edit1.SetSel(-1);&#x2F;&#x2F;使用一次就行，代表可以使用\r\n分行</span><br><span class="line">m_edit1.ReplaceSel(&quot;abcdefg&quot;);&#x2F;&#x2F;显示字符串</span><br><span class="line">m_edit1.ReplaceSel(out);&#x2F;&#x2F;显示变量（char或CString）</span><br><span class="line">m_edit1.ReplaceSel(&quot;\r\n&quot;);&#x2F;&#x2F;换行</span><br></pre></td></tr></table></figure>
<p>这里的<strong>m_edit1</strong>并不是ID，而是类。那么如何建立类向导呢？</p>
<ul>
<li>窗体任意位置右键</li>
<li>建立类向导</li>
<li>Member Variables<br><img src="https://s1.ax1x.com/2020/03/21/8RPxRU.jpg" alt></li>
<li>点击Add Variable…为IDC_EDIT1这个编辑框建立一个类。</li>
<li>这里类的名称要写成 <strong>“m_…”</strong> 的形式。更重要的是<strong>Category</strong>一定要选择<strong>Control</strong>！！！<br><img src="https://s1.ax1x.com/2020/03/21/8RP5RS.jpg" alt></li>
<li>点击OK完成。</li>
</ul>
<h4 id="复选框和单选框"><a href="#复选框和单选框" class="headerlink" title="复选框和单选框"></a>复选框和单选框</h4><p>在串口调试助手中我们经常会用定时发送等功能，那么复选框就可以提供选择是否要进行某一操作的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(((CButton*)GetDlgItem(IDC_CHECK1))-&gt;GetCheck()&#x3D;&#x3D;TRUE)</span><br><span class="line">	&#x2F;&#x2F;勾选</span><br><span class="line">else</span><br><span class="line">	&#x2F;&#x2F;未勾选</span><br></pre></td></tr></table></figure>
<p>这里判断的<strong>TRUE</strong>是复选框勾选的状态。</p>
<p>单选框不建议使用，因为单选框<strong>选中后不可取消</strong>。</p>
<h4 id="组合框"><a href="#组合框" class="headerlink" title="组合框"></a>组合框</h4><p>非常实用的一个窗口控件，我们在制作上位机时，会提供给用户可选的串口号等等。</p>
<h5 id="组合框添加内容"><a href="#组合框添加内容" class="headerlink" title="组合框添加内容"></a>组合框添加内容</h5><p>我们想要在程序运行开始后让组合框中出现下拉列表，就要在MFC初始化时将组合框的初始化添加进去。</p>
<p>第一步还是要建类，我们命名为<strong>m_cbCom</strong>。<br>之后我们在程序中找到<strong>BOOL CHostcomputerDlg::OnInitDialog()</strong>这个函数，在程序开头附近，这是MFC控件初始化的函数。</p>
<p>在此函数末尾<strong>// TODO: Add extra initialization here</strong>下，<strong>return TRUE;</strong>前，添加初始化代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m_cbCom.InsertString(0,&quot;-请选择-&quot;);</span><br><span class="line">m_cbCom.InsertString(1,&quot;COM 1&quot;);</span><br><span class="line">m_cbCom.InsertString(2,&quot;COM 2&quot;);</span><br><span class="line">m_cbCom.InsertString(3,&quot;COM 3&quot;);</span><br><span class="line">m_cbCom.InsertString(4,&quot;COM 4&quot;);</span><br><span class="line">m_cbCom.InsertString(5,&quot;COM 5&quot;);</span><br><span class="line">m_cbCom.InsertString(6,&quot;COM 6&quot;);</span><br><span class="line">m_cbCom.InsertString(7,&quot;COM 7&quot;);</span><br><span class="line">m_cbCom.InsertString(8,&quot;COM 8&quot;);</span><br><span class="line">m_cbCom.InsertString(9,&quot;COM 9&quot;);</span><br><span class="line">m_cbCom.InsertString(10,&quot;COM 10&quot;);</span><br></pre></td></tr></table></figure>

<p>这里的序号要从0开始，双引号中是显示的内容。</p>
<h5 id="获取用户选择的序号"><a href="#获取用户选择的序号" class="headerlink" title="获取用户选择的序号"></a>获取用户选择的序号</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int com;</span><br><span class="line">com&#x3D;m_cbCom.GetCurSel();</span><br></pre></td></tr></table></figure>
<p>这里获取的是用户选择的项的序号。</p>
<h5 id="组合框没有下拉菜单的问题"><a href="#组合框没有下拉菜单的问题" class="headerlink" title="组合框没有下拉菜单的问题"></a>组合框没有下拉菜单的问题</h5><p>鼠标放在组合框下拉箭头上，可以看到鼠标编程了上下指向的箭头，单击，则可以将组合框下拉菜单的高度改变。这是初学者经常遭遇的一个难题。再次点击切换回横向拉伸组合框。</p>
<h4 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h4><p>想要实时显示滑块值，个人使用的是定时器每隔100ms获取一次滑块位置并在其后加一个编辑框，显示数值的方法。<br><img src="https://s1.ax1x.com/2020/03/21/8RPhPf.jpg" alt></p>
<h5 id="滑块初始化"><a href="#滑块初始化" class="headerlink" title="滑块初始化"></a>滑块初始化</h5><p>滑块的使用也需要建立类。<br>和上面的其他控件一样，我们在初始化函数下加入代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m_timslider.SetRange(10,1000);</span><br><span class="line">m_timslider.SetTicFreq(10);</span><br></pre></td></tr></table></figure>
<p>这里的<strong>SetRange</strong>代表的是滑块的范围是10-1000，最小为10，最大为1000，<strong>SetTicFreq</strong>代表滑块移动的最小单位为10。</p>
<h5 id="滑块值获取"><a href="#滑块值获取" class="headerlink" title="滑块值获取"></a>滑块值获取</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int slider;</span><br><span class="line">slider&#x3D;m_timslider.GetPos();</span><br></pre></td></tr></table></figure>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><h5 id="添加定时器函数"><a href="#添加定时器函数" class="headerlink" title="添加定时器函数"></a>添加定时器函数</h5><p>定时器控件不同于窗口中的其他控件，我们需要在类向导中添加。<br><img src="https://s1.ax1x.com/2020/03/21/8RPIxg.jpg" alt><br>点击<strong>Add Function</strong>，<strong>Edit Code</strong>，即可修改添加到程序中的定时器函数。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CHostcomputerDlg::OnTimer(UINT nIDEvent) </span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default</span><br><span class="line">	</span><br><span class="line">	CDialog::OnTimer(nIDEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定时器初始化"><a href="#定时器初始化" class="headerlink" title="定时器初始化"></a>定时器初始化</h5><p>同样在初始化函数中，添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SetTimer(1,50,NULL);</span><br></pre></td></tr></table></figure>
<p>这里定义了定时器1，50ms中断一次。和芯片不同，我们的电脑可以模拟出很多个定时器，你可以定义2，3，4….</p>
<h5 id="定时器关闭"><a href="#定时器关闭" class="headerlink" title="定时器关闭"></a>定时器关闭</h5><p>例如关闭定时器1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KillTimer(1);</span><br></pre></td></tr></table></figure>
<h5 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h5><p>这里列举两个定时器的中断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CSwjDlg::OnTimer(UINT nIDEvent) </span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default</span><br><span class="line">	switch(nIDEvent)</span><br><span class="line">	&#123;</span><br><span class="line">	case 1:&#x2F;&#x2F;定时器1中断</span><br><span class="line">    	m_edit1.ReplaceSel(&quot;abcdefg&quot;);</span><br><span class="line">		m_edit1.ReplaceSel(&quot;\r\n&quot;);&#x2F;&#x2F;换行</span><br><span class="line">		break;</span><br><span class="line">		</span><br><span class="line">	case 2:&#x2F;&#x2F;定时器2中断</span><br><span class="line">    	com&#x3D;m_cbCom.GetCurSel();&#x2F;&#x2F;获取滑块位置</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	CDialog::OnTimer(nIDEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h4><p><img src="https://s1.ax1x.com/2020/03/21/8RPRat.jpg" alt><br>建立m_Progress类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m_Progress.SetRange(0,100);&#x2F;&#x2F;设置进度条的数值范围</span><br><span class="line">m_Progress.SetStep(10);&#x2F;&#x2F;设置单步长度如10</span><br><span class="line">m_Progress.StepIt();&#x2F;&#x2F;走一步</span><br><span class="line">m_Progress.SetPos(50);&#x2F;&#x2F;设置进度条在自定义的位置如50</span><br><span class="line">n&#x3D;m_Progress.GetPos();&#x2F;&#x2F;获取当前位置</span><br></pre></td></tr></table></figure>

<h4 id="串口控件"><a href="#串口控件" class="headerlink" title="串口控件"></a>串口控件</h4><h5 id="添加串口控件"><a href="#添加串口控件" class="headerlink" title="添加串口控件"></a>添加串口控件</h5><p>窗体右键 <strong>插入ActiveX控件</strong><br><img src="https://s1.ax1x.com/2020/03/21/8RPWIP.jpg" alt></p>
<p>在窗口上会出现一个小电话图标，这就是串口控件。这个图片在运行程序时是看不到的。<br>之后建立<strong>m_ctrlComm</strong>类。</p>
<h5 id="串口的打开"><a href="#串口的打开" class="headerlink" title="串口的打开"></a>串口的打开</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m_ctrlComm.SetCommPort(com);&#x2F;&#x2F;com为串口号</span><br><span class="line">if (m_ctrlComm.GetPortOpen())&#x2F;&#x2F;如果串口已经打开</span><br><span class="line">&#123;</span><br><span class="line">	m_ctrlComm.SetPortOpen(FALSE);&#x2F;&#x2F;不再重复打开</span><br><span class="line">&#125;</span><br><span class="line">if(!m_ctrlComm.GetPortOpen())&#x2F;&#x2F;串口没有打开</span><br><span class="line">&#123;</span><br><span class="line">	m_ctrlComm.SetPortOpen(TRUE);&#x2F;&#x2F;打开串口</span><br><span class="line">	SetDlgItemText(IDC_EDIT1,&quot;串口已打开&quot;);</span><br><span class="line">&#125;</span><br><span class="line">m_ctrlComm.SetInputMode(1);</span><br><span class="line">m_ctrlComm.SetSettings(&quot;4800,n,8,1&quot;);&#x2F;&#x2F;波特率</span><br><span class="line">m_ctrlComm.SetRThreshold(1);</span><br><span class="line">m_ctrlComm.SetInputLen(0);</span><br><span class="line">m_ctrlComm.GetInput();</span><br></pre></td></tr></table></figure>
<h5 id="串口发送"><a href="#串口发送" class="headerlink" title="串口发送"></a>串口发送</h5><p>Format函数我们要经常使用在串口发送数据的处理上。<br>格式：</p>
<p><strong>[CString].Format(“%s或%c或%d”，[char]或[int])</strong></p>
<h6 id="普通字符串"><a href="#普通字符串" class="headerlink" title="普通字符串"></a>普通字符串</h6><p>个人建议使用CString发送，因为这样非常稳定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CString send;</span><br><span class="line">char a[]&#x3D;&#123;&quot;abcd&quot;&#125;</span><br><span class="line">send.Format(&quot;%s&quot;,a);</span><br><span class="line">m_ctrlComm.SetOutput(COleVariant(&quot;abcd&quot;));&#x2F;&#x2F;字符串</span><br><span class="line">m_ctrlComm.SetOutput(COleVariant(send));&#x2F;&#x2F;发送变量</span><br></pre></td></tr></table></figure>
<h6 id="发送整型数"><a href="#发送整型数" class="headerlink" title="发送整型数"></a>发送整型数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CString send;</span><br><span class="line">int a&#x3D;123;</span><br><span class="line">send.Format(&quot;%d&quot;,a);</span><br><span class="line">m_ctrlComm.SetOutput(COleVariant(send));&#x2F;&#x2F;发送变量</span><br></pre></td></tr></table></figure>
<h5 id="串口接收"><a href="#串口接收" class="headerlink" title="串口接收"></a>串口接收</h5><p>双击小电话，可以进入串口函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int data[]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void CSTM32_HIDDlg::OnOnCommMscomm() </span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; TODO: Add your control notification handler code here</span><br><span class="line">	VARIANT vReceive;</span><br><span class="line">	int len;</span><br><span class="line">	byte sBuf;</span><br><span class="line">	char rec[5];&#x2F;&#x2F;根据接收数据长度定义既可</span><br><span class="line">	if(m_ctrlComm.GetCommEvent()&#x3D;&#x3D;2)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		len&#x3D;m_ctrlComm.GetInBufferCount();</span><br><span class="line">		m_ctrlComm.SetInputLen(len);</span><br><span class="line">		vReceive&#x3D;m_ctrlComm.GetInput();</span><br><span class="line">		byte* buf&#x3D;new byte[len];</span><br><span class="line">		memcpy(buf,(byte*)vReceive.parray-&gt;pvData,len);</span><br><span class="line">		for(int i&#x3D;0;i&lt;len;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sBuf&#x3D;*(buf+i);</span><br><span class="line">			data[i]&#x3D;sBuf;</span><br><span class="line">			rec[i]&#x3D;sBuf;</span><br><span class="line">		&#125;</span><br><span class="line">		delete buf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的rec是储存接收信息的变量。<br><strong>注意：下位机一定要发送十六进制数据，普通的字符串会出现乱码。</strong><br>例:可在串口函数中判断rec第一位数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(rec[0]&#x3D;&#x3D;0x01)</span><br><span class="line">	m_edit.ReplaceSel(&quot;接收到0x01\r\n&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="MFC其他技巧"><a href="#MFC其他技巧" class="headerlink" title="MFC其他技巧"></a>MFC其他技巧</h4><h5 id="1-弹出另一个窗口和关闭"><a href="#1-弹出另一个窗口和关闭" class="headerlink" title="1.弹出另一个窗口和关闭"></a>1.弹出另一个窗口和关闭</h5><p>点击<strong>插入，窗体</strong>，名称可以自定义，点击确定。</p>
<p>在主窗体添加新窗体的头文件，可以去新窗体程序中查看，其头文件为<strong>名称.h</strong>。</p>
<p>加入新窗体名称为<strong>help</strong>，可以在主窗体的按钮中添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help dlg;   &#x2F;&#x2F; 对话框类对象</span><br><span class="line"></span><br><span class="line">dlg.DoModal();</span><br></pre></td></tr></table></figure>

<p>关闭新窗体可以在新窗体中操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EndDialog(0);</span><br></pre></td></tr></table></figure>
<p>即可关闭所在窗体。</p>
<h5 id="2-定时关闭新窗体"><a href="#2-定时关闭新窗体" class="headerlink" title="2.定时关闭新窗体"></a>2.定时关闭新窗体</h5><p>添加定时器控件，之后在新窗体的<br><strong>void open::DoDataExchange(CDataExchange* pDX)</strong><br>函数尾部添加定时器初始化。<br>在定时器中断中添加关闭指令。</p>
<h5 id="3-播放音乐"><a href="#3-播放音乐" class="headerlink" title="3.播放音乐"></a>3.播放音乐</h5><p>一般播放wav格式的音乐，我们可以音频转码成wav再播放</p>
<h6 id="本地文件中的音乐"><a href="#本地文件中的音乐" class="headerlink" title="本地文件中的音乐"></a>本地文件中的音乐</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line">#include &quot;mmsystem.h&quot; &#x2F;&#x2F;头文件</span><br><span class="line"></span><br><span class="line">PlaySound(完整路径和后缀, AfxGetInstanceHandle(), SND_RESOURCE | SND_ASYNC);</span><br></pre></td></tr></table></figure>
<h6 id="编译到程序资源的音乐"><a href="#编译到程序资源的音乐" class="headerlink" title="编译到程序资源的音乐"></a>编译到程序资源的音乐</h6><p>这种方式可以让音乐代码加入到程序中，无需外部文件。<br><strong>插入，资源，引入</strong>，选择文件类型为wav波形文件，选择相应文件即可将wav加入到资源中。<br>左侧资源窗中可以看到wav的名称为<strong>IDR_WAVE1</strong>或其他名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;windows.h&quot;</span><br><span class="line">#include &quot;mmsystem.h&quot; &#x2F;&#x2F;头文件</span><br><span class="line"></span><br><span class="line">PlaySound((LPCTSTR)IDR_WAVE1, AfxGetInstanceHandle(), SND_RESOURCE | SND_ASYNC);</span><br></pre></td></tr></table></figure>
<h6 id="单次播放，循环播放，停止播放"><a href="#单次播放，循环播放，停止播放" class="headerlink" title="单次播放，循环播放，停止播放"></a>单次播放，循环播放，停止播放</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PlaySound((LPCTSTR)IDR_WAVE1, AfxGetInstanceHandle(), SND_RESOURCE | SND_ASYNC| SND_LOOP);</span><br><span class="line">&#x2F;&#x2F;加入SND_LOOP为循环播放，否则为单次</span><br><span class="line"></span><br><span class="line">PlaySound(NULL,NULL,SND_FILENAME | SND_ASYNC | SND_LOOP);</span><br><span class="line">&#x2F;&#x2F;停止所有音乐播放</span><br></pre></td></tr></table></figure>
<h5 id="4-显示图片"><a href="#4-显示图片" class="headerlink" title="4.显示图片"></a>4.显示图片</h5><h6 id="添加资源"><a href="#添加资源" class="headerlink" title="添加资源"></a>添加资源</h6><p>建议使用bmp图片，如果加入图片失败请尝试将像素减少。<br>无法编辑属于可以正常显示的情况。<br><strong>插入，资源，引入</strong>选择文件类型为所有文件，点击bmp格式的图片即可添加。<br>左侧资源窗体上可见其名称。</p>
<h6 id="添加图片控件"><a href="#添加图片控件" class="headerlink" title="添加图片控件"></a>添加图片控件</h6><p>控件栏上的图像控件，在窗体上框出希望的大小。<br>右键属性。<br><strong>类型</strong>：位图<br><strong>图像</strong>：图像ID</p>
<h5 id="5-更换程序图标"><a href="#5-更换程序图标" class="headerlink" title="5.更换程序图标"></a>5.更换程序图标</h5><p>在工程文件夹下，找到<strong>res</strong>下的ico文件，将想替换的图标替换其即可。</p>
<h2 id="五、END"><a href="#五、END" class="headerlink" title="五、END"></a>五、END</h2><p>编译好的可执行文件在工程文件Debug下哦！(｡・`ω´･)</p>
]]></content>
  </entry>
  <entry>
    <title>如何制作一台多功能循迹蓝牙遥控小车</title>
    <url>/2020/02/20/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E5%8F%B0%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%BE%AA%E8%BF%B9%E8%93%9D%E7%89%99%E9%81%A5%E6%8E%A7%E5%B0%8F%E8%BD%A6/</url>
    <content><![CDATA[<h2 id="在刚接触51单片机的时候觉得这是很难的事情"><a href="#在刚接触51单片机的时候觉得这是很难的事情" class="headerlink" title="在刚接触51单片机的时候觉得这是很难的事情"></a>在刚接触51单片机的时候觉得这是很难的事情</h2><p>记录蓝牙小车的制作过程<br><img src="https://ae01.alicdn.com/kf/H2c517b909dbd4e5ba2a3b6ec558a75d6W.jpg" alt></p>
<a id="more"></a>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>不要觉得它很难，就像在做一个玩具一样。蓝牙小车对于初学者是道坎，pwm调速这个就难到了很多人，其实这些都不难。</p>
<h3 id="二、什么是pwm调速"><a href="#二、什么是pwm调速" class="headerlink" title="二、什么是pwm调速"></a>二、什么是pwm调速</h3><p>网上是这么说的：</p>
<p><strong>PWM(Pulse Width Modulation)控制——脉冲宽度调制技术，通过对一系列脉冲的宽度进行调制，来等效地获得所需要波形(含形状和幅值)。</strong></p>
<p>但其实我们只需要记住两个词：<br><strong>周期</strong>和<strong>占空比</strong></p>
<p>在调速这方面，控制pwm就相当于控制你多长时间手动按一次按键和你每次按下按键的时长，来控制一只led。pwm的<strong>周期</strong>就是你按下按键的间隔，<strong>占空比</strong>就是你按下的时间。</p>
<ul>
<li><p>如果你每隔1秒按下一次，并且按下的时间为0.5秒，那么人眼可以看到led是在闪烁的状态。</p>
</li>
<li><p>如果你操作够快，达到ms级别，那么人眼是看不出来你每隔10ms按下一次且每次按下5ms，这时候可以用一个一直通电的led和你控制的led做对比，你会发现你控制的led亮度大约是一直通电的1/2。</p>
</li>
<li><p>如果你改变了按下的时间，周期不变，例如你只有2ms的时间按下，你会发现这比5ms按下更暗，而且大约是一直通电亮度的1/5。</p>
</li>
</ul>
<p>如果把led换成电机，那么你就完成了调速，速度就是亮度，他们都是看你pwm波的有效值。也可以理解成电阻，通电时间也就是按下时间越长，发热量越大。<br><img src="https://s1.ax1x.com/2020/03/20/8cWzIU.jpg" alt><br>也就是说你控制的设备输出的功率就是pwm的占空比，占空比为50%的话，输出也就是最大功率的1/2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">sbit out1&#x3D;P2^0;</span><br><span class="line">sbit out2&#x3D;P2^1;</span><br><span class="line">sbit out3&#x3D;P2^2;</span><br><span class="line">sbit out4&#x3D;P2^3;&#x2F;&#x2F;四个输出</span><br><span class="line"></span><br><span class="line">int n,speed1,speed2,speed3,speed4;</span><br><span class="line">void InitTimer0(void)&#x2F;&#x2F;定时器初始化，这里设定了1ms定时</span><br><span class="line">&#123;</span><br><span class="line">    TMOD &#x3D; 0x01;</span><br><span class="line">    TH0 &#x3D; 0x0FC;</span><br><span class="line">    TL0 &#x3D; 0x18;</span><br><span class="line">    EA &#x3D; 1;</span><br><span class="line">    ET0 &#x3D; 1;</span><br><span class="line">    TR0 &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	InitTimer0();	</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		speed1&#x3D;20;</span><br><span class="line">		speed2&#x3D;50;</span><br><span class="line">		speed3&#x3D;70;</span><br><span class="line">		speed4&#x3D;90;&#x2F;&#x2F;设定四个输出的占空比</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer0Interrupt(void) interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 &#x3D; 0x0FC;</span><br><span class="line">    TL0 &#x3D; 0x18;</span><br><span class="line">    n++;</span><br><span class="line">	if(n&#x3D;&#x3D;100)&#x2F;&#x2F;设定周期100ms</span><br><span class="line">		n&#x3D;0;</span><br><span class="line">	if(n&lt;speed1)</span><br><span class="line">		out1&#x3D;1;</span><br><span class="line">	else</span><br><span class="line">		out1&#x3D;0;</span><br><span class="line">	if(n&lt;speed2)</span><br><span class="line">		out2&#x3D;1;</span><br><span class="line">	else</span><br><span class="line">		out2&#x3D;0;</span><br><span class="line">	if(n&lt;speed3)</span><br><span class="line">		out3&#x3D;1;</span><br><span class="line">	else</span><br><span class="line">		out3&#x3D;0;</span><br><span class="line">	if(n&lt;speed4)</span><br><span class="line">		out4&#x3D;1;</span><br><span class="line">	else</span><br><span class="line">		out4&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/20/8cWvZV.jpg" alt><br>这里我们可以看到四个输出pwm明显的区别，20%，50%，70%，90%。</p>
<h3 id="三、如何驱动电机"><a href="#三、如何驱动电机" class="headerlink" title="三、如何驱动电机"></a>三、如何驱动电机</h3><p>仅仅靠单片机的io口输出的电流来控制电机是远远不够的</p>
<p>51单片机io口输入电流限制在10ma左右，输出电流在10ua左右，加上拉电阻也只能达到20ma左右，这并不足以驱动需要较大电流的电机。</p>
<p>这个时候我们就需要使用电机驱动模块。</p>
<p>电机驱动模块也有很多种，一般驱动小减速电机我们可以使用L298N系列的驱动模块，如果驱动较大的减速电机我们就要使用mos管驱动。</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8cWH2j.jpg" alt></p>
<p>这是我们最常用的L298N电机驱动模块，使用很简单<br><img src="https://s1.ax1x.com/2020/03/20/8cW7GQ.jpg" alt></p>
<p>也有这种体积较小的L298N，但是他的使用比较严格，电压不得超过10V，安装也不是很方便，初学者不建议使用。</p>
<p>我们还是来看第一种体积比较大的L298N</p>
<table>
<thead>
<tr>
<th>管脚</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td>VCC</td>
<td align="left">12V电源接口</td>
</tr>
<tr>
<td>GND</td>
<td align="left">接地</td>
</tr>
<tr>
<td>5V</td>
<td align="left">12V转5V的输出接口，单片机可以用这个5V供电</td>
</tr>
<tr>
<td>ENA，ENB</td>
<td align="left">调速管脚，不需要调速时短接</td>
</tr>
<tr>
<td>IN1-4</td>
<td align="left">电机方向控制</td>
</tr>
</tbody></table>
<h4 id="1-电源和接地"><a href="#1-电源和接地" class="headerlink" title="1.电源和接地"></a>1.电源和接地</h4><ul>
<li>VCC可以使用12V航模电池或2-3节18650电池供电。</li>
<li>5V可以给单片机和其他5V设备供电。</li>
<li>GND是共地，很多初学者会忘记将单片机和驱动模块共地，导致不能控制</li>
</ul>
<h4 id="2-方向控制管脚"><a href="#2-方向控制管脚" class="headerlink" title="2.方向控制管脚"></a>2.方向控制管脚</h4><p>in1,in2,in3,in4控制两端电机，in1和in2控制其左端输出，in3和in4控制其右端输出。</p>
<p>以控制左端为例，我们可以将in1和in2理解为电动势，如果in1和in2都为0或1，没有产生电势差，此时也就没有电流输出。</p>
<p>如果in1为0，in2为1，产生了电动势，此时输出端输出电流，可以观察电机转向，反之in1为1，in2为0，则电机与刚才相比反转。</p>
<p>右端同理，就是控制输出端电流方向。</p>
<h4 id="3-调速管脚"><a href="#3-调速管脚" class="headerlink" title="3.调速管脚"></a>3.调速管脚</h4><p>如果不需要调速，那么就不用拔掉短接冒，此时调速管脚接的是高电平，也就是100%的占空比信号，电机全速转动。</p>
<p>如果需要调速，那么拔掉短接冒，和in1-4同排的管脚是你需要和单片机相连的管脚，此时你可以在ENA或ENB上给予pwm信号，它的速度是百分之几就等于你的占空比。</p>
<h4 id="4-输出"><a href="#4-输出" class="headerlink" title="4.输出"></a>4.输出</h4><p>每个L298N有两个输出，能控制两侧电机。如果我们制作四轮小车，个人还是建议使用一个L298N，一侧控制两个电机，这样可以避免因为L298N的性能问题，导致前后轮出现速度不同的现象。</p>
<h4 id="5-为什么要用减速电机"><a href="#5-为什么要用减速电机" class="headerlink" title="5.为什么要用减速电机"></a>5.为什么要用减速电机</h4><p>减速电机内部是一个普通的马达，不同减速电机内部构造不同，但都是一个原理：<br><strong>牺牲距离增加做功</strong></p>
<p>其内部是减速齿轮组，夸张的说，马达转10圈时可能外部才转一圈，这样减速电机的力气更大，更重要的是这样更加容易控制速度，我们控制马达转一周很难，但我们粗略的控制它转100圈左右更加容易，所以我们控制减速电机的行驶速度和距离也就更加的容易。</p>
<h3 id="四、循迹"><a href="#四、循迹" class="headerlink" title="四、循迹"></a>四、循迹</h3><p>循迹是作为智能小车的一大重点，在地上铺设白底黑线，小车就能够沿着黑线行驶，这是怎么做到的呢？<br>我们这里就需要使用循迹模块。</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8cWXq0.jpg" alt></p>
<p>循迹模块也是需要VCC接5V，GND接地，还有两个管脚一个AO一个DO，我们使用DO管脚就可以，AO是AD输出暂时用不到。</p>
<p><strong>原理</strong>：利用了在不同的颜色下红外反射强度不同，比如在白色条件下，红外线很容易就反射回来，黑色条件下，红外线会被黑色吸收而无法返回，这样就区分出了两种颜色。</p>
<p><strong>蓝色电位器</strong>是用来调节检测的颜色，在比赛前的调试过程中必不可少的就是调节电位器，让其明显区分出循迹线和底板。</p>
<p>循迹模块的数量可以根据实际情况而定。</p>
<h4 id="1-二路循迹"><a href="#1-二路循迹" class="headerlink" title="1.二路循迹"></a>1.二路循迹</h4><p>二路循迹比较简单，有两种编程思路。</p>
<h5 id="第一种：鬼畜式纯电路循迹（自己起的名字）"><a href="#第一种：鬼畜式纯电路循迹（自己起的名字）" class="headerlink" title="第一种：鬼畜式纯电路循迹（自己起的名字）"></a>第一种：鬼畜式纯电路循迹（自己起的名字）</h5><p>不常用性能也不好，不需要芯片控制</p>
<p>这种循迹只需要控制左右转或者差速转向，也就是两侧车轮没有同速直线行驶的情况。<br>本人做的第一个循迹小车就是这种循迹方式，简答纯电路就可以驱动。</p>
<p>常常适用于两个后轮驱动，前方一个万向轮的三轮小车。<br><img src="https://s1.ax1x.com/2020/03/20/8cfFMR.jpg" alt><br>** 思路**：前方两个循迹模块，控制继电器即可。一旦左侧检测到黑线，证明车体方向偏右，就需要向左转，这时候左轮不动，右轮前进。一旦右侧检测到黑线，证明车体方向偏左，就需要向右转，右轮不动左轮前进。这时候我们看到的结果就是小车在左右摇摆着沿着黑线行驶。</p>
<h5 id="第二种：简单二路的循迹"><a href="#第二种：简单二路的循迹" class="headerlink" title="第二种：简单二路的循迹"></a>第二种：简单二路的循迹</h5><p>这是我们最常用的一种二路循迹，性能较好，适用于全部车型。<br><img src="https://s1.ax1x.com/2020/03/20/8cfks1.jpg" alt><br>两个循迹模块之间的距离稍稍大于循迹线宽即可。</p>
<ul>
<li>当左侧检测到黑线，车体左转。</li>
<li>当右侧检测到黑线，车体右转</li>
<li>当左右都没有检测到黑线时，证明黑线在两个模块之间，车体前进（暂不考虑冲出轨道的情况）</li>
</ul>
<h4 id="2-三路循迹"><a href="#2-三路循迹" class="headerlink" title="2.三路循迹"></a>2.三路循迹</h4><p>三路循迹与二路相比更加准确，一般用于直角转弯或者精度较高的情况。<br>和二路循迹一样，两侧模块用来检测车体偏左还是偏右，可以当中间的模块检测到黑线时才开始前进。</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8cfCRJ.jpg" alt></p>
<p>直角转弯时，黑线不会在两侧的模块以内，这时候就需要在黑线接近时，可用中间模块判断车体是否准确的对准了黑线。</p>
<h4 id="3-直角弯循迹"><a href="#3-直角弯循迹" class="headerlink" title="3.直角弯循迹"></a>3.直角弯循迹</h4><p>有些时候我们需要走一个直角弯，这个时候我们就需要在车体两侧加装循迹模块。<br><img src="https://s1.ax1x.com/2020/03/20/8cf9G4.jpg" alt><br>两侧模块用来检测是否到达了直角弯，一旦检测到黑线，就原地转向。</p>
<h4 id="4-差速行驶"><a href="#4-差速行驶" class="headerlink" title="4.差速行驶"></a>4.差速行驶</h4><p>循迹的过过程中，要想保证速度或经过S弯等情况下，就需要使用差速。</p>
<p>差速就是两侧车轮同向转动但是速度不同，这样的效果就是小车实现S形走位，也可以实现在高速行驶的情况下微调方向。</p>
<h4 id="5-PID算法"><a href="#5-PID算法" class="headerlink" title="5.PID算法"></a>5.PID算法</h4><p>比较高级的循迹可以用到<strong>PID</strong>算法，使用差速来校准方向，但这种方法比较难用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _pid </span><br><span class="line">&#123;</span><br><span class="line">	float ExpectedValue;&#x2F;&#x2F;定义设定值</span><br><span class="line">	float ActualValue;&#x2F;&#x2F;定义实际值</span><br><span class="line">	float err;&#x2F;&#x2F;定义偏差值</span><br><span class="line">	float err_last;&#x2F;&#x2F;定义上一个偏差值</span><br><span class="line">	float err_prev;&#x2F;&#x2F;定义前一个的偏差值</span><br><span class="line">	float Kp, Ki, Kd;&#x2F;&#x2F;定义比例、积分、微分系数</span><br><span class="line">&#125;pid;</span><br><span class="line"> </span><br><span class="line">void PID_Init()</span><br><span class="line">&#123;</span><br><span class="line">	pid.ExpectedValue &#x3D; 0.0;</span><br><span class="line">	pid.ActualValue &#x3D; 0.0;</span><br><span class="line">	pid.err &#x3D; 0.0;</span><br><span class="line">	pid.err_prev &#x3D; 0.0;</span><br><span class="line">	pid.err_last &#x3D; 0.0;</span><br><span class="line">	pid.Kp &#x3D; 0.4;</span><br><span class="line">	pid.Ki &#x3D; 0.2;</span><br><span class="line">	pid.Kd &#x3D; 0.0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">float PID_Realize(float speed) &#123;</span><br><span class="line">	float index;</span><br><span class="line">	pid.ExpectedValue &#x3D; speed;</span><br><span class="line">	pid.err &#x3D; pid.ExpectedValue - pid.ActualValue;</span><br><span class="line">	&#x2F;&#x2F;增量式pid公式</span><br><span class="line">	float incrementValue &#x3D; pid.Kp*(pid.err - pid.err_last) + pid.Ki*pid.err + pid.Kd*(pid.err - 2 * pid.err_last + pid.err_prev);</span><br><span class="line">	pid.ActualValue +&#x3D; incrementValue;</span><br><span class="line">	pid.err_prev &#x3D; pid.err_last;</span><br><span class="line">	pid.err_last &#x3D; pid.err;</span><br><span class="line">	return pid.ActualValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、扩展功能"><a href="#五、扩展功能" class="headerlink" title="五、扩展功能"></a>五、扩展功能</h3><h4 id="1、遥控"><a href="#1、遥控" class="headerlink" title="1、遥控"></a>1、遥控</h4><p>遥控可以有很多方案：</p>
<ul>
<li>蓝牙串口</li>
<li>JDY-40</li>
<li>nrf2401</li>
<li>WIFI</li>
</ul>
<p>用51单片机的就可以使用蓝牙和JDY-40。</p>
<p>蓝牙模块可以实现手机控制，手机下载蓝牙串口调试软件，和蓝牙模块配对即可。</p>
<p>JDY-40，可以使用另一个51芯片来控制。</p>
<p><strong>注意：JDY-40供电电压严格要求3.3V，可以使用稳压芯片转换电压。</strong><br><img src="https://s1.ax1x.com/2020/03/20/8cfVZ6.jpg" alt><br>使用串口遥控时，单片机要注意更换<strong>11.0592M晶振</strong>，尽量使用9600或115200的波特率，例如JDY-40的初始波特率为9600。<br>如果在调试过程中出现了乱码，那么首先就要确认两个设备的波特率是否相同，以及<strong>RXD</strong>和<strong>TXD</strong>是否连接正确。</p>
<p>发送的数据使用十六进制即可，例如0x01。</p>
<h4 id="2、舵机"><a href="#2、舵机" class="headerlink" title="2、舵机"></a>2、舵机</h4><p>舵机可以搭载超声波，摄像头等。可以在车辆上制作一个二轴云台，并实现控制。<br><img src="https://s1.ax1x.com/2020/03/20/8cfZdK.jpg" alt></p>
<p>我们比较常用的sg90，相比金属舵机肯定是微不足道，但是它的性能足以让我们做一些小型的开发。</p>
<p>它的控制原理和pwm调速相似，但是它的周期是固定的。</p>
<p>舵机驱动的<strong>周期是20ms</strong>，<strong>占空比为0.5-2.5ms</strong>,也就是0-180度。</p>
<table>
<thead>
<tr>
<th>时间(ms)</th>
<th align="left">角度</th>
</tr>
</thead>
<tbody><tr>
<td>0.5</td>
<td align="left">0</td>
</tr>
<tr>
<td>1.0</td>
<td align="left">45</td>
</tr>
<tr>
<td>1.5</td>
<td align="left">90</td>
</tr>
<tr>
<td>2.0</td>
<td align="left">135</td>
</tr>
<tr>
<td>2.5</td>
<td align="left">180</td>
</tr>
</tbody></table>
<p>当然它的角度是线性变化的，并非固定只有5个角度。</p>
<h4 id="3、同时使用串口和定时器"><a href="#3、同时使用串口和定时器" class="headerlink" title="3、同时使用串口和定时器"></a>3、同时使用串口和定时器</h4><p>这里需要将<strong>TMOD</strong>改为<strong>0X21</strong></p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void TimeInit()&#x2F;&#x2F;定时器和串口同时初始化</span><br><span class="line">&#123;</span><br><span class="line">	SCON&#x3D;0X50;		</span><br><span class="line">	TMOD|&#x3D;0X21;		</span><br><span class="line">	PCON&#x3D;0X80;			</span><br><span class="line">	TH1 &#x3D; 0xF3;</span><br><span class="line">    TL1 &#x3D; TH1;</span><br><span class="line">    TR1&#x3D;1;	</span><br><span class="line">    TH0 &#x3D; 0x0FF;</span><br><span class="line">    TL0 &#x3D; 0x9C;</span><br><span class="line">    ET0 &#x3D; 1;</span><br><span class="line">    TR0 &#x3D; 1;</span><br><span class="line">	ES&#x3D;1;					</span><br><span class="line">	EA&#x3D;1;						</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、超声波避障等"><a href="#4、超声波避障等" class="headerlink" title="4、超声波避障等"></a>4、超声波避障等</h4><p>可以看本站关于超声波的文章</p>
<p>超声波模块HC-SR04四针通用延时驱动:<br><a href="https://square0097.github.io/2020/02/18/HC-SR04/" target="_blank" rel="noopener">https://square0097.github.io/2020/02/18/HC-SR04/</a></p>
<p>超声可以实现避障和倒车自停功能。</p>
<h4 id="5、常见故障问题解决"><a href="#5、常见故障问题解决" class="headerlink" title="5、常见故障问题解决"></a>5、常见故障问题解决</h4><h5 id="1-在进行停车或起步等一些动作时，出现重启现象"><a href="#1-在进行停车或起步等一些动作时，出现重启现象" class="headerlink" title="1.在进行停车或起步等一些动作时，出现重启现象**"></a>1.在进行停车或起步等一些动作时，出现重启现象**</h5><p>这里是因为电机在启动或停止瞬间电流消耗过大，引起的单片机电流不足断电，导致重启。</p>
<p><strong>解决方法</strong>：在单片机的VCC和GND之间加一个电容即可，容值越大效果越好。</p>
<h5 id="2-舵机运行时导致重启"><a href="#2-舵机运行时导致重启" class="headerlink" title="2.舵机运行时导致重启"></a>2.舵机运行时导致重启</h5><p>同样是耗电的原因，舵机的耗电相比电机要高，所以这里建议单独为舵机供电。</p>
<p><strong>解决办法</strong>：外加3.7V电池为舵机供电，注意共地。</p>
<h3 id="六、END"><a href="#六、END" class="headerlink" title="六、END"></a>六、END</h3><p>暂时就总结这么多，希望能对大家有所帮助！</p>
]]></content>
  </entry>
  <entry>
    <title>Jlink修复和JTAG龙邱K60、STM32C8T6程序下载</title>
    <url>/2020/02/19/Jlink%E4%BF%AE%E5%A4%8D%E5%92%8CJTAG%E9%BE%99%E9%82%B1K60%E3%80%81STM32C8T6%E7%A8%8B%E5%BA%8F%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="开始学习龙邱K60，但是不知道如何转接JTAG，有个Jlink还不好使的怎么办？C8T6也想用Jlink下载怎么办？"><a href="#开始学习龙邱K60，但是不知道如何转接JTAG，有个Jlink还不好使的怎么办？C8T6也想用Jlink下载怎么办？" class="headerlink" title="开始学习龙邱K60，但是不知道如何转接JTAG，有个Jlink还不好使的怎么办？C8T6也想用Jlink下载怎么办？"></a>开始学习龙邱K60，但是不知道如何转接JTAG，有个Jlink还不好使的怎么办？C8T6也想用Jlink下载怎么办？</h2><p>本篇主要记录如何修复Jlink，以及龙邱K60如何使用20针转接和C8T6如何连接Jlink<br><img src="https://ae01.alicdn.com/kf/H2e7564ce7c2f43829d1acdbd5b68fe7aC.jpg" alt></p>
<a id="more"></a>
<h3 id="一、如何修复Jlink"><a href="#一、如何修复Jlink" class="headerlink" title="一、如何修复Jlink"></a>一、如何修复Jlink</h3><p>一般情况下可能是固件丢失，我们可以尝试重新刷写固件，如果设备管理器仍然识别不了，那就可能是硬件问题。</p>
<h4 id="1-下载和安装烧录软件"><a href="#1-下载和安装烧录软件" class="headerlink" title="1.下载和安装烧录软件"></a>1.下载和安装烧录软件</h4><p>链接：<a href="https://pan.baidu.com/s/1GnowM-hvnPJJ6nIFYQleFA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GnowM-hvnPJJ6nIFYQleFA</a><br>提取码：klzs</p>
<p>内含烧录软件以及V8固件<br>直接安装<br><strong>sam-ba-2.12.exe</strong></p>
<h4 id="2-Jlink硬件复位"><a href="#2-Jlink硬件复位" class="headerlink" title="2.Jlink硬件复位"></a>2.Jlink硬件复位</h4><p>拆开Jlink，就可以看到 <strong>EREASE</strong> 和 <strong>TST</strong> 等标识的接口</p>
<ul>
<li>首先连接<strong>USB</strong></li>
<li>短接<strong>EREASE</strong>子祥处接口10秒以上</li>
<li>断开<strong>EREASE</strong>短接后再断开<strong>USB</strong></li>
<li>短接<strong>TST</strong>处接口</li>
<li>连接<strong>USB</strong>约20秒</li>
<li>断开<strong>USB</strong>再断开短接</li>
</ul>
<h4 id="3-刷写新的固件"><a href="#3-刷写新的固件" class="headerlink" title="3.刷写新的固件"></a>3.刷写新的固件</h4><ul>
<li><p>连接<strong>USB</strong>,打开<strong>sam-ba.exe</strong>，可以看到有设备连接，点击<strong>Connect</strong>,如果没有<strong>Connect</strong>怎么办，可以往下拉一下窗口，可能是被挡住了<br><img src="https://s1.ax1x.com/2020/03/21/8RFG7R.jpg" alt></p>
</li>
<li><p>选择<strong>Send File Name</strong>,找到文件中的V8固件，并点击<strong>Send File</strong><br><img src="https://s1.ax1x.com/2020/03/21/8Wweu8.jpg" alt></p>
</li>
<li><p>下面会出现两次询问窗口，第一次是是否解锁，我们选择<strong>Yes</strong>，第二次是是否锁定，我们选择<strong>No</strong><br><img src="https://s1.ax1x.com/2020/03/21/8RFYA1.jpg" alt><br>这一套操作下来V8固件重刷就完成了</p>
</li>
</ul>
<h4 id="4-Keil5无法使用此Jlink"><a href="#4-Keil5无法使用此Jlink" class="headerlink" title="4.Keil5无法使用此Jlink"></a>4.Keil5无法使用此Jlink</h4><p>Keil5默认的Jlink驱动是很高版本的，我们需要替换成低版本的Jlink驱动。</p>
<p>官网下载<a href="https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack" target="_blank" rel="noopener">https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack</a></p>
<p>建议下载Jlink_V490</p>
<p>下载后找到</p>
<ul>
<li><strong>JFink.exe</strong></li>
<li><strong>JlinkARM.dll</strong></li>
<li><strong>JlinkRDI.dll</strong></li>
</ul>
<p>复制到<strong>keil5/ARM/Segger</strong>替换原文件</p>
<p>完成后发现Jlink已经可以正常使用</p>
<h3 id="二、龙邱K60如何转接"><a href="#二、龙邱K60如何转接" class="headerlink" title="二、龙邱K60如何转接"></a>二、龙邱K60如何转接</h3><p>看图，按照途中管脚接线<br><img src="https://s1.ax1x.com/2020/03/21/8RF8B9.png" alt><br>这里<strong>RST</strong>接<strong>SRST_N</strong>即可</p>
<p>我在Jlink内部连接好了下载线，在外壳上扣了一个洞方便插线<br><img src="https://s1.ax1x.com/2020/03/21/8WBgtH.jpg" alt></p>
<h3 id="三、STM32C8T6怎样使用Jlink下载？"><a href="#三、STM32C8T6怎样使用Jlink下载？" class="headerlink" title="三、STM32C8T6怎样使用Jlink下载？"></a>三、STM32C8T6怎样使用Jlink下载？</h3><p>这个接不方便做出标准的外接口，因为A13、A14引脚并未在普通管脚中引出，不过可以将4针焊下替换成40针同向的向下排针，方便插在洞洞板上。</p>
<p><img src="https://s1.ax1x.com/2020/03/21/8WwEgP.jpg" alt></p>
<p>也可以使用龙邱K60下载接口，PB4的JTRST可不接，不影响下载。</p>
<p><img src="https://s1.ax1x.com/2020/03/21/8WwA3t.jpg" alt></p>
<p><strong>注意</strong> ：JTAG上靠近VCC的的 <strong>nTRST</strong> 不可接C8T6的RST。</p>
<h3 id="四、使用Keil5为K60下载时选错版本上锁"><a href="#四、使用Keil5为K60下载时选错版本上锁" class="headerlink" title="四、使用Keil5为K60下载时选错版本上锁"></a>四、使用Keil5为K60下载时选错版本上锁</h3><p>现象为提示未找到芯片，使用IAR下载一次即可，一路点击“是”即可下载，之后再换Keil5时发现可以正常下载。</p>
<h3 id="五、常见K60故障"><a href="#五、常见K60故障" class="headerlink" title="五、常见K60故障"></a>五、常见K60故障</h3><h4 id="K60有发烫"><a href="#K60有发烫" class="headerlink" title="K60有发烫"></a>K60有发烫</h4><p>的毛病的时候千万不可一直插着电源,这是内部io已经击穿，撑不了多久就会坏掉。</p>
<h4 id="判断芯片是否烧坏"><a href="#判断芯片是否烧坏" class="headerlink" title="判断芯片是否烧坏"></a>判断芯片是否烧坏</h4><p>检测VCC与GND之间电阻，在120欧左右为正常，100以下已经烧坏。</p>
]]></content>
  </entry>
  <entry>
    <title>OpenMV与单片机串口通信问题</title>
    <url>/2020/02/19/OpenMV%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码"><a href="#之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码" class="headerlink" title="之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码"></a>之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码</h2><p>本文记录了其串口通信的方法<br><img src="https://ae01.alicdn.com/kf/He03a513d19e648edb70676fb7bb96e9ae.jpg" alt></p>
<a id="more"></a>

<h2 id="OpenMV串口通信"><a href="#OpenMV串口通信" class="headerlink" title="OpenMV串口通信"></a>OpenMV串口通信</h2><p>openmv的管脚为数不多，我们要想做到控制更多的模块就要将他作为一个图像处理的传感器，把信息传输给我们用的其他芯片。<br><img src="https://s1.ax1x.com/2020/03/21/8WrjmV.jpg" alt></p>
<h3 id="1-串口管脚"><a href="#1-串口管脚" class="headerlink" title="1.串口管脚"></a>1.串口管脚</h3><p><strong>P4 TXD</strong></p>
<p><strong>P5 RXD</strong></p>
<h3 id="2-串口初始化"><a href="#2-串口初始化" class="headerlink" title="2.串口初始化"></a>2.串口初始化</h3><p>python下的代码很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time, pyb</span><br><span class="line">from pyb import UART</span><br><span class="line"></span><br><span class="line">uart &#x3D; UART(3, 115200, timeout_char&#x3D;1000)</span><br><span class="line"></span><br><span class="line">led_blue &#x3D; pyb.LED(3)&#x2F;&#x2F;这是自带的led，可以作为指示灯使用</span><br><span class="line">led_red &#x3D; pyb.LED(2)</span><br></pre></td></tr></table></figure>
<h3 id="3-串口发送"><a href="#3-串口发送" class="headerlink" title="3.串口发送"></a>3.串口发送</h3><p>普通发送字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uart.write(str)&#x2F;&#x2F;发送str字符串</span><br><span class="line">uart.write(&quot;abc&quot;)&#x2F;&#x2F;发送abc</span><br></pre></td></tr></table></figure>
<p>发送整形数就要用到json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;123</span><br><span class="line">y&#x3D;234</span><br><span class="line">str&#x3D;&#39;横坐标为&#39;+json.dumps(x)+&#39;纵坐标为&#39;+json.dumps(y)</span><br><span class="line">uart.write(str)</span><br></pre></td></tr></table></figure>
<h3 id="4、串口接收"><a href="#4、串口接收" class="headerlink" title="4、串口接收"></a>4、串口接收</h3><p>例如利用串口控制两个小led</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if uart.any():</span><br><span class="line">        a&#x3D;uart.readline().decode()</span><br><span class="line">        print(a)&#x2F;&#x2F;打印到终端</span><br><span class="line">        if a&#x3D;&#x3D;&#39;abc&#39;:</span><br><span class="line">            led_blue.on()</span><br><span class="line">            led_red.off()</span><br><span class="line">        if a&#x3D;&#x3D;&#39;abd&#39;:</span><br><span class="line">            led_blue.off()</span><br><span class="line">            led_red.on()</span><br></pre></td></tr></table></figure>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>注意，供电不得使用3.3V接口</p>
]]></content>
  </entry>
  <entry>
    <title>超声波模块HC-SR04四针通用延时驱动</title>
    <url>/2020/02/18/HC-SR04/</url>
    <content><![CDATA[<h2 id="对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？"><a href="#对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？" class="headerlink" title="对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？"></a>对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？</h2><p>本文意在让初学者学会使用超声波模块<br><img src="https://ae01.alicdn.com/kf/Hd941248583e744c8bfa57e8399c3c403h.jpg" alt></p>
<a id="more"></a>

<h2 id="一、模块简介"><a href="#一、模块简介" class="headerlink" title="一、模块简介"></a>一、模块简介</h2><p>超声波模块我们在很多领域都能得到应用<br><img src="https://s1.ax1x.com/2020/03/21/8RPtbR.jpg" alt><br>HC-SR04模块使用很简单，我们使用它来制作一些小设备完全足够。<br>我们一般的思路就是使用定时器，这样是非常准确的。</p>
<h3 id="1-基本参数"><a href="#1-基本参数" class="headerlink" title="1.基本参数"></a>1.基本参数</h3><ul>
<li>使用电压：DC—5V   </li>
<li>静态电流：小于2mA       </li>
<li>电平输出：高5V     </li>
<li>电平输出：底0V         </li>
<li>感应角度：不大于15度    </li>
<li>探测距离：2cm-450cm </li>
<li>测量精度：可达0.2cm   <h3 id="2-时序"><a href="#2-时序" class="headerlink" title="2.时序"></a>2.时序</h3><img src="https://s1.ax1x.com/2020/03/21/8RPYr9.png" alt><h3 id="3-管脚"><a href="#3-管脚" class="headerlink" title="3.管脚"></a>3.管脚</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="center">管脚</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">VCC</td>
<td align="center">5V电源接口</td>
</tr>
<tr>
<td align="center">GND</td>
<td align="center">接地</td>
</tr>
<tr>
<td align="center">Echo</td>
<td align="center">信号输出</td>
</tr>
<tr>
<td align="center">Trig</td>
<td align="center">信号输入</td>
</tr>
</tbody></table>
<h2 id="二、驱动思路"><a href="#二、驱动思路" class="headerlink" title="二、驱动思路"></a>二、驱动思路</h2><p>简单的来说，就说我们只需要掌握</p>
<ul>
<li>如何触发模块</li>
<li>触发后如何获取信息<h3 id="1-触发"><a href="#1-触发" class="headerlink" title="1.触发"></a>1.触发</h3>从时序中可以看到，Trig信号输入引脚只需要给10us高电平，就能够触发模块工作<h3 id="2-接收"><a href="#2-接收" class="headerlink" title="2.接收"></a>2.接收</h3>我们只需要等待Echo管脚的高电平，并从记录下高电平的时间即可。<h3 id="3-计算"><a href="#3-计算" class="headerlink" title="3.计算"></a>3.计算</h3>公式：距离=高电平时间*声速(340M/S)/2。</li>
</ul>
<h2 id="三、51代码函数"><a href="#三、51代码函数" class="headerlink" title="三、51代码函数"></a>三、51代码函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void delay10us(void)   &#x2F;&#x2F;误差 0us</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a,b;</span><br><span class="line">    for(b&#x3D;1;b&gt;0;b--)</span><br><span class="line">        for(a&#x3D;1;a&gt;0;a--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float count()&#x2F;&#x2F;超声波函数</span><br><span class="line">&#123;</span><br><span class="line">	int s&#x3D;0,n;</span><br><span class="line">    float distance;</span><br><span class="line">	Trig&#x3D;1;&#x2F;&#x2F;触发引脚拉高</span><br><span class="line">	delay10us();</span><br><span class="line">	Trig&#x3D;0;&#x2F;&#x2F;触发引脚拉低</span><br><span class="line">	while(Echo!&#x3D;1)&#x2F;&#x2F;等待响应</span><br><span class="line">    &#123;</span><br><span class="line">  		delay10us();</span><br><span class="line">        n++;</span><br><span class="line">        if(n&#x3D;&#x3D;2000)&#x2F;&#x2F;超出响应时间</span><br><span class="line">        	return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	while(Exho&#x3D;&#x3D;1)&#x2F;&#x2F;得到响应</span><br><span class="line">	&#123;</span><br><span class="line">		 delay10us();</span><br><span class="line">		 s++;&#x2F;&#x2F;计数</span><br><span class="line">	&#125;</span><br><span class="line">    distance&#x3D;s*0.0034;</span><br><span class="line">	return distance;&#x2F;&#x2F;返回值为cm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么使用10us延时，可能大家会有疑问，这个是取决于机器周期的，不能生成1us的延时函数。</p>
<h2 id="四、END"><a href="#四、END" class="headerlink" title="四、END"></a>四、END</h2><p>延时看起来比较简单，但是实际上却有着一定误差，如果可以使用定时器那是最好的。</p>
<p>相信看完这个时序就能理解超声波模块的驱动方法了，<br>定时器驱动大同小异。</p>
]]></content>
  </entry>
  <entry>
    <title>AT89C52RC/RD系列贴片与P4管脚的使用</title>
    <url>/2020/02/18/AT89C52/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽然51系列性能相比stm32系列简直是很鸡肋，但是考虑到成本和使用简单的问题，在开发较小的不需要复杂功能的设备上，个人比较倾向于使用51的贴片。<br><img src="https://ae01.alicdn.com/kf/Hc5fd0d830dba4b7c99550a9977f17043m.jpg" alt></p>
<a id="more"></a>

<h4 id="为啥突然想弄这个了呢"><a href="#为啥突然想弄这个了呢" class="headerlink" title="为啥突然想弄这个了呢"></a>为啥突然想弄这个了呢</h4><p>疫情发展得很迅速，快递全都躺在路上了，补番补得头疼，手头也没什么东西能玩的。看到在路上的51贴片里有P4这个管脚，但是我们51标准的头文件里没有P4管脚的相关定义，于是在家无聊的时间里研究了一下51贴片系列如何使用P4管脚。</p>
<h2 id="一、AT89C51RC-RD系列贴片封装"><a href="#一、AT89C51RC-RD系列贴片封装" class="headerlink" title="一、AT89C51RC/RD系列贴片封装"></a>一、AT89C51RC/RD系列贴片封装</h2><p>首先我们来看一下他的尺寸，因为毕竟是贴片要打PCB板的，我也是在网上找了很久才找到弄好的封装，不然就要自己手画了。</p>
<h3 id="1-尺寸"><a href="#1-尺寸" class="headerlink" title="1.尺寸"></a>1.尺寸</h3><p><img src="https://s1.ax1x.com/2020/03/20/8cROAO.png" alt><br>这是官方文件里51贴片的尺寸图，用来参考整体尺寸还可以，个人觉得管脚尺寸有一些出入。<br>我这里有弄好的51贴片AD封装，需要的加我QQ。</p>
<h3 id="2-管脚"><a href="#2-管脚" class="headerlink" title="2.管脚"></a>2.管脚</h3><p><img src="https://s1.ax1x.com/2020/03/20/8cRqHK.png" alt></p>
<p>官方文档里给出的管脚图，我在网上找到的封装里是没有写P4管脚的，写的都是NC，所以要是想使用P4管脚就看这个管脚图吧。</p>
<h2 id="二、P4管脚的功能"><a href="#二、P4管脚的功能" class="headerlink" title="二、P4管脚的功能"></a>二、P4管脚的功能</h2><p>同样我们还是在官方文档里找，我找了半天，文件页数太多了…<br>其他管脚的功能和直插版的普通芯片是一样的。</p>
<table>
<thead>
<tr>
<th>管脚</th>
<th align="center">编号</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>P4.0</td>
<td align="center">17</td>
<td align="center">标准I/O口 PORT4[0]</td>
</tr>
<tr>
<td>P4.1</td>
<td align="center">28</td>
<td align="center">标准I/O口 PORT4[1]</td>
</tr>
<tr>
<td>P4.2 / INT3</td>
<td align="center">39</td>
<td align="center">标准I/O口 PORT4[2]；外部中断3，低电平或下降沿中断</td>
</tr>
<tr>
<td>P4.3 / INT2</td>
<td align="center">6</td>
<td align="center">标准I/O口 PORT4[3]；外部中断2，低电平或下降沿中断</td>
</tr>
<tr>
<td>P4.4 / PSEN</td>
<td align="center">26</td>
<td align="center">标准I/O口 PORT4[4]；外部程序储存器选通信号输出引脚</td>
</tr>
<tr>
<td>P4.5 / ALE</td>
<td align="center">27</td>
<td align="center">标准I/O口 PORT4[5]；地址锁存允许信号输出引脚/编程脉冲输入引脚</td>
</tr>
<tr>
<td>P4.6 / EA</td>
<td align="center">29</td>
<td align="center">标准I/O口 PORT4[6]；内外存储器选择引脚</td>
</tr>
</tbody></table>
<p>其实直插芯片里也引出了P4管脚，我们只是不知道哈哈哈</p>
<h2 id="三、如何使用P4管脚"><a href="#三、如何使用P4管脚" class="headerlink" title="三、如何使用P4管脚"></a>三、如何使用P4管脚</h2><p>为了使用P4我们首先要在标准头文件中添加P4的地址</p>
<p>在开头位置找到管脚定义   BYTE Registers<br>可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*  BYTE Registers  *&#x2F;</span><br><span class="line">sfr P0    &#x3D; 0x80;</span><br><span class="line">sfr P1    &#x3D; 0x90;</span><br><span class="line">sfr P2    &#x3D; 0xA0;</span><br><span class="line">sfr P3    &#x3D; 0xB0;</span><br><span class="line">sfr P4    &#x3D; 0xE8;&#x2F;&#x2F;后加的</span><br><span class="line">sfr PSW   &#x3D; 0xD0;</span><br><span class="line">sfr ACC   &#x3D; 0xE0;</span><br><span class="line">sfr B     &#x3D; 0xF0;</span><br><span class="line">sfr SP    &#x3D; 0x81;</span><br><span class="line">sfr DPL   &#x3D; 0x82;</span><br><span class="line">sfr DPH   &#x3D; 0x83;</span><br><span class="line">sfr PCON  &#x3D; 0x87;</span><br><span class="line">sfr TCON  &#x3D; 0x88;</span><br><span class="line">sfr TMOD  &#x3D; 0x89;</span><br><span class="line">sfr TL0   &#x3D; 0x8A;</span><br><span class="line">sfr TL1   &#x3D; 0x8B;</span><br><span class="line">sfr TH0   &#x3D; 0x8C;</span><br><span class="line">sfr TH1   &#x3D; 0x8D;</span><br><span class="line">sfr IE    &#x3D; 0xA8;</span><br><span class="line">sfr IP    &#x3D; 0xB8;</span><br><span class="line">sfr SCON  &#x3D; 0x98;</span><br><span class="line">sfr SBUF  &#x3D; 0x99;</span><br></pre></td></tr></table></figure>
<p>P4管脚加进来就好了,如果没有看文档的话可能就定义0xC0了…，8，9，A,B,C刚刚好是不是。</p>
<p>但是，官方文档中写了P4是0xE8！！！</p>
<p><strong>这里要注意的是，虽然P4引脚都写有标准IO口的字样，但是 P4.4 P4.5 P4.6 不建议使用！！！！亲测无法控制这三个引脚</strong></p>
<h2 id="四、END"><a href="#四、END" class="headerlink" title="四、END"></a>四、END</h2><p>希望各位大佬们熬过疫情&lt;(▰˘◡˘▰)&gt;<br>有问题可以联系我哦</p>
]]></content>
  </entry>
</search>
