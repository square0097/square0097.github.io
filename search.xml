<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何制作一台多功能循迹蓝牙遥控小车</title>
    <url>/2020/02/20/car/</url>
    <content><![CDATA[<h2 id="在刚接触51单片机的时候觉得这是很难的事情"><a href="#在刚接触51单片机的时候觉得这是很难的事情" class="headerlink" title="在刚接触51单片机的时候觉得这是很难的事情"></a>在刚接触51单片机的时候觉得这是很难的事情</h2><p>记录蓝牙小车的制作过程<br><img src="http://q5y0th4yi.bkt.clouddn.com/car001.jpg" alt></p>
<a id="more"></a>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>不要觉得它很难，就像在做一个玩具一样。蓝牙小车对于初学者是道坎，pwm调速这个就难到了很多人，其实这些都不难。</p>
<h3 id="二、什么是pwm调速"><a href="#二、什么是pwm调速" class="headerlink" title="二、什么是pwm调速"></a>二、什么是pwm调速</h3><p>网上是这么说的：</p>
<p><strong>PWM(Pulse Width Modulation)控制——脉冲宽度调制技术，通过对一系列脉冲的宽度进行调制，来等效地获得所需要波形(含形状和幅值)。</strong></p>
<p>但其实我们只需要记住两个词：<br><strong>周期</strong>和<strong>占空比</strong></p>
<p>在调速这方面，控制pwm就相当于控制你多长时间手动按一次按键和你每次按下按键的时长，来控制一只led。pwm的<strong>周期</strong>就是你按下按键的间隔，<strong>占空比</strong>就是你按下的时间。</p>
<ul>
<li><p>如果你每隔1秒按下一次，并且按下的时间为0.5秒，那么人眼可以看到led是在闪烁的状态。</p>
</li>
<li><p>如果你操作够快，达到ms级别，那么人眼是看不出来你每隔10ms按下一次且每次按下5ms，这时候可以用一个一直通电的led和你控制的led做对比，你会发现你控制的led亮度大约是一直通电的1/2。</p>
</li>
<li><p>如果你改变了按下的时间，周期不变，例如你只有2ms的时间按下，你会发现这比5ms按下更暗，而且大约是一直通电亮度的1/5。</p>
</li>
</ul>
<p>如果把led换成电机，那么你就完成了调速，速度就是亮度，他们都是看你pwm波的有效值。也可以理解成电阻，通电时间也就是按下时间越长，发热量越大。<br><img src="http://q5y0th4yi.bkt.clouddn.com/car002.jpg" alt><br>也就是说你控制的设备输出的功率就是pwm的占空比，占空比为50%的话，输出也就是最大功率的1/2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">sbit out1&#x3D;P2^0;</span><br><span class="line">sbit out2&#x3D;P2^1;</span><br><span class="line">sbit out3&#x3D;P2^2;</span><br><span class="line">sbit out4&#x3D;P2^3;&#x2F;&#x2F;四个输出</span><br><span class="line"></span><br><span class="line">int n,speed1,speed2,speed3,speed4;</span><br><span class="line">void InitTimer0(void)&#x2F;&#x2F;定时器初始化，这里设定了1ms定时</span><br><span class="line">&#123;</span><br><span class="line">    TMOD &#x3D; 0x01;</span><br><span class="line">    TH0 &#x3D; 0x0FC;</span><br><span class="line">    TL0 &#x3D; 0x18;</span><br><span class="line">    EA &#x3D; 1;</span><br><span class="line">    ET0 &#x3D; 1;</span><br><span class="line">    TR0 &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	InitTimer0();	</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		speed1&#x3D;20;</span><br><span class="line">		speed2&#x3D;50;</span><br><span class="line">		speed3&#x3D;70;</span><br><span class="line">		speed4&#x3D;90;&#x2F;&#x2F;设定四个输出的占空比</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Timer0Interrupt(void) interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 &#x3D; 0x0FC;</span><br><span class="line">    TL0 &#x3D; 0x18;</span><br><span class="line">    n++;</span><br><span class="line">	if(n&#x3D;&#x3D;100)&#x2F;&#x2F;设定周期100ms</span><br><span class="line">		n&#x3D;0;</span><br><span class="line">	if(n&lt;speed1)</span><br><span class="line">		out1&#x3D;1;</span><br><span class="line">	else</span><br><span class="line">		out1&#x3D;0;</span><br><span class="line">	if(n&lt;speed2)</span><br><span class="line">		out2&#x3D;1;</span><br><span class="line">	else</span><br><span class="line">		out2&#x3D;0;</span><br><span class="line">	if(n&lt;speed3)</span><br><span class="line">		out3&#x3D;1;</span><br><span class="line">	else</span><br><span class="line">		out3&#x3D;0;</span><br><span class="line">	if(n&lt;speed4)</span><br><span class="line">		out4&#x3D;1;</span><br><span class="line">	else</span><br><span class="line">		out4&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://q5y0th4yi.bkt.clouddn.com/car002_0.JPG" alt><br>这里我们可以看到四个输出pwm明显的区别，20%，50%，70%，90%。</p>
<h3 id="三、如何驱动电机"><a href="#三、如何驱动电机" class="headerlink" title="三、如何驱动电机"></a>三、如何驱动电机</h3><p>仅仅靠单片机的io口输出的电流来控制电机是远远不够的</p>
<p>51单片机io口输入电流限制在10ma左右，输出电流在10ua左右，加上拉电阻也只能达到20ma左右，这并不足以驱动需要较大电流的电机。</p>
<p>这个时候我们就需要使用电机驱动模块。</p>
<p>电机驱动模块也有很多种，一般驱动小减速电机我们可以使用L298N系列的驱动模块，如果驱动较大的减速电机我们就要使用mos管驱动。</p>
<p><img src="http://q5y0th4yi.bkt.clouddn.com/car003.jpg" alt></p>
<p>这是我们最常用的L298N电机驱动模块，使用很简单<br><img src="http://q5y0th4yi.bkt.clouddn.com/car004.jpg" alt></p>
<p>也有这种体积较小的L298N，但是他的使用比较严格，电压不得超过10V，安装也不是很方便，初学者不建议使用。</p>
<p>我们还是来看第一种体积比较大的L298N</p>
<table>
<thead>
<tr>
<th>管脚</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td>VCC</td>
<td align="left">12V电源接口</td>
</tr>
<tr>
<td>GND</td>
<td align="left">接地</td>
</tr>
<tr>
<td>5V</td>
<td align="left">12V转5V的输出接口，单片机可以用这个5V供电</td>
</tr>
<tr>
<td>ENA，ENB</td>
<td align="left">调速管脚，不需要调速时短接</td>
</tr>
<tr>
<td>IN1-4</td>
<td align="left">电机方向控制</td>
</tr>
</tbody></table>
<h4 id="1-电源和接地"><a href="#1-电源和接地" class="headerlink" title="1.电源和接地"></a>1.电源和接地</h4><ul>
<li>VCC可以使用12V航模电池或2-3节18650电池供电。</li>
<li>5V可以给单片机和其他5V设备供电。</li>
<li>GND是共地，很多初学者会忘记将单片机和驱动模块共地，导致不能控制</li>
</ul>
<h4 id="2-方向控制管脚"><a href="#2-方向控制管脚" class="headerlink" title="2.方向控制管脚"></a>2.方向控制管脚</h4><p>in1,in2,in3,in4控制两端电机，in1和in2控制其左端输出，in3和in4控制其右端输出。</p>
<p>以控制左端为例，我们可以将in1和in2理解为电动势，如果in1和in2都为0或1，没有产生电势差，此时也就没有电流输出。</p>
<p>如果in1为0，in2为1，产生了电动势，此时输出端输出电流，可以观察电机转向，反之in1为1，in2为0，则电机与刚才相比反转。</p>
<p>右端同理，就是控制输出端电流方向。</p>
<h4 id="3-调速管脚"><a href="#3-调速管脚" class="headerlink" title="3.调速管脚"></a>3.调速管脚</h4><p>如果不需要调速，那么就不用拔掉短接冒，此时调速管脚接的是高电平，也就是100%的占空比信号，电机全速转动。</p>
<p>如果需要调速，那么拔掉短接冒，和in1-4同排的管脚是你需要和单片机相连的管脚，此时你可以在ENA或ENB上给予pwm信号，它的速度是百分之几就等于你的占空比。</p>
<h4 id="4-输出"><a href="#4-输出" class="headerlink" title="4.输出"></a>4.输出</h4><p>每个L298N有两个输出，能控制两侧电机。如果我们制作四轮小车，个人还是建议使用一个L298N，一侧控制两个电机，这样可以避免因为L298N的性能问题，导致前后轮出现速度不同的现象。</p>
<h4 id="5-为什么要用减速电机"><a href="#5-为什么要用减速电机" class="headerlink" title="5.为什么要用减速电机"></a>5.为什么要用减速电机</h4><p>减速电机内部是一个普通的马达，不同减速电机内部构造不同，但都是一个原理：<br><strong>牺牲距离增加做功</strong></p>
<p>其内部是减速齿轮组，夸张的说，马达转10圈时可能外部才转一圈，这样减速电机的力气更大，更重要的是这样更加容易控制速度，我们控制马达转一周很难，但我们粗略的控制它转100圈左右更加容易，所以我们控制减速电机的行驶速度和距离也就更加的容易。</p>
<h3 id="四、循迹"><a href="#四、循迹" class="headerlink" title="四、循迹"></a>四、循迹</h3><p>循迹是作为智能小车的一大重点，在地上铺设白底黑线，小车就能够沿着黑线行驶，这是怎么做到的呢？<br>我们这里就需要使用循迹模块。</p>
<p><img src="http://q5y0th4yi.bkt.clouddn.com/car005.jpg" alt></p>
<p>循迹模块也是需要VCC接5V，GND接地，还有两个管脚一个AO一个DO，我们使用DO管脚就可以，AO是AD输出暂时用不到。</p>
<p><strong>原理</strong>：利用了在不同的颜色下红外反射强度不同，比如在白色条件下，红外线很容易就反射回来，黑色条件下，红外线会被黑色吸收而无法返回，这样就区分出了两种颜色。</p>
<p><strong>蓝色电位器</strong>是用来调节检测的颜色，在比赛前的调试过程中必不可少的就是调节电位器，让其明显区分出循迹线和底板。</p>
<p>循迹模块的数量可以根据实际情况而定。</p>
<h4 id="1-二路循迹"><a href="#1-二路循迹" class="headerlink" title="1.二路循迹"></a>1.二路循迹</h4><p>二路循迹比较简单，有两种编程思路。</p>
<h5 id="第一种：鬼畜式纯电路循迹（自己起的名字）"><a href="#第一种：鬼畜式纯电路循迹（自己起的名字）" class="headerlink" title="第一种：鬼畜式纯电路循迹（自己起的名字）"></a>第一种：鬼畜式纯电路循迹（自己起的名字）</h5><p>不常用性能也不好，不需要芯片控制</p>
<p>这种循迹只需要控制左右转或者差速转向，也就是两侧车轮没有同速直线行驶的情况。<br>本人做的第一个循迹小车就是这种循迹方式，简答纯电路就可以驱动。</p>
<p>常常适用于两个后轮驱动，前方一个万向轮的三轮小车。<br><img src="http://q5y0th4yi.bkt.clouddn.com/car006.jpg" alt><br>** 思路**：前方两个循迹模块，控制继电器即可。一旦左侧检测到黑线，证明车体方向偏右，就需要向左转，这时候左轮不动，右轮前进。一旦右侧检测到黑线，证明车体方向偏左，就需要向右转，右轮不动左轮前进。这时候我们看到的结果就是小车在左右摇摆着沿着黑线行驶。</p>
<h5 id="第二种：简单二路的循迹"><a href="#第二种：简单二路的循迹" class="headerlink" title="第二种：简单二路的循迹"></a>第二种：简单二路的循迹</h5><p>这是我们最常用的一种二路循迹，性能较好，适用于全部车型。<br><img src="http://q5y0th4yi.bkt.clouddn.com/car007.jpg" alt><br>两个循迹模块之间的距离稍稍大于循迹线宽即可。</p>
<ul>
<li>当左侧检测到黑线，车体左转。</li>
<li>当右侧检测到黑线，车体右转</li>
<li>当左右都没有检测到黑线时，证明黑线在两个模块之间，车体前进（暂不考虑冲出轨道的情况）</li>
</ul>
<h4 id="2-三路循迹"><a href="#2-三路循迹" class="headerlink" title="2.三路循迹"></a>2.三路循迹</h4><p>三路循迹与二路相比更加准确，一般用于直角转弯或者精度较高的情况。<br>和二路循迹一样，两侧模块用来检测车体偏左还是偏右，可以当中间的模块检测到黑线时才开始前进。</p>
<p><img src="http://q5y0th4yi.bkt.clouddn.com/car008.jpg" alt></p>
<p>直角转弯时，黑线不会在两侧的模块以内，这时候就需要在黑线接近时，可用中间模块判断车体是否准确的对准了黑线。</p>
<h4 id="3-直角弯循迹"><a href="#3-直角弯循迹" class="headerlink" title="3.直角弯循迹"></a>3.直角弯循迹</h4><p>有些时候我们需要走一个直角弯，这个时候我们就需要在车体两侧加装循迹模块。<br><img src="http://q5y0th4yi.bkt.clouddn.com/car009.jpg" alt><br>两侧模块用来检测是否到达了直角弯，一旦检测到黑线，就原地转向。</p>
<h4 id="4-差速行驶"><a href="#4-差速行驶" class="headerlink" title="4.差速行驶"></a>4.差速行驶</h4><p>循迹的过过程中，要想保证速度或经过S弯等情况下，就需要使用差速。</p>
<p>差速就是两侧车轮同向转动但是速度不同，这样的效果就是小车实现S形走位，也可以实现在高速行驶的情况下微调方向。</p>
<h4 id="5-PID算法"><a href="#5-PID算法" class="headerlink" title="5.PID算法"></a>5.PID算法</h4><p>比较高级的循迹可以用到<strong>PID</strong>算法，使用差速来校准方向，但这种方法比较难用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _pid </span><br><span class="line">&#123;</span><br><span class="line">	float ExpectedValue;&#x2F;&#x2F;定义设定值</span><br><span class="line">	float ActualValue;&#x2F;&#x2F;定义实际值</span><br><span class="line">	float err;&#x2F;&#x2F;定义偏差值</span><br><span class="line">	float err_last;&#x2F;&#x2F;定义上一个偏差值</span><br><span class="line">	float err_prev;&#x2F;&#x2F;定义前一个的偏差值</span><br><span class="line">	float Kp, Ki, Kd;&#x2F;&#x2F;定义比例、积分、微分系数</span><br><span class="line">&#125;pid;</span><br><span class="line"> </span><br><span class="line">void PID_Init()</span><br><span class="line">&#123;</span><br><span class="line">	pid.ExpectedValue &#x3D; 0.0;</span><br><span class="line">	pid.ActualValue &#x3D; 0.0;</span><br><span class="line">	pid.err &#x3D; 0.0;</span><br><span class="line">	pid.err_prev &#x3D; 0.0;</span><br><span class="line">	pid.err_last &#x3D; 0.0;</span><br><span class="line">	pid.Kp &#x3D; 0.4;</span><br><span class="line">	pid.Ki &#x3D; 0.2;</span><br><span class="line">	pid.Kd &#x3D; 0.0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">float PID_Realize(float speed) &#123;</span><br><span class="line">	float index;</span><br><span class="line">	pid.ExpectedValue &#x3D; speed;</span><br><span class="line">	pid.err &#x3D; pid.ExpectedValue - pid.ActualValue;</span><br><span class="line">	&#x2F;&#x2F;增量式pid公式</span><br><span class="line">	float incrementValue &#x3D; pid.Kp*(pid.err - pid.err_last) + pid.Ki*pid.err + pid.Kd*(pid.err - 2 * pid.err_last + pid.err_prev);</span><br><span class="line">	pid.ActualValue +&#x3D; incrementValue;</span><br><span class="line">	pid.err_prev &#x3D; pid.err_last;</span><br><span class="line">	pid.err_last &#x3D; pid.err;</span><br><span class="line">	return pid.ActualValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、扩展功能"><a href="#五、扩展功能" class="headerlink" title="五、扩展功能"></a>五、扩展功能</h3><h4 id="1、遥控"><a href="#1、遥控" class="headerlink" title="1、遥控"></a>1、遥控</h4><p>遥控可以有很多方案：</p>
<ul>
<li>蓝牙串口</li>
<li>JDY-40</li>
<li>nrf2401</li>
<li>WIFI</li>
</ul>
<p>用51单片机的就可以使用蓝牙和JDY-40。</p>
<p>蓝牙模块可以实现手机控制，手机下载蓝牙串口调试软件，和蓝牙模块配对即可。</p>
<p>JDY-40，可以使用另一个51芯片来控制。</p>
<p><strong>注意：JDY-40供电电压严格要求3.3V，可以使用稳压芯片转换电压。</strong><br><img src="http://q5y0th4yi.bkt.clouddn.com/car010.jpg" alt><br>使用串口遥控时，单片机要注意更换<strong>11.0592M晶振</strong>，尽量使用9600或115200的波特率，例如JDY-40的初始波特率为9600。<br>如果在调试过程中出现了乱码，那么首先就要确认两个设备的波特率是否相同，以及<strong>RXD</strong>和<strong>TXD</strong>是否连接正确。</p>
<p>发送的数据使用十六进制即可，例如0x01。</p>
<h4 id="2、舵机"><a href="#2、舵机" class="headerlink" title="2、舵机"></a>2、舵机</h4><p>舵机可以搭载超声波，摄像头等。可以在车辆上制作一个二轴云台，并实现控制。<br><img src="http://q5y0th4yi.bkt.clouddn.com/car011.jpg" alt></p>
<p>我们比较常用的sg90，相比金属舵机肯定是微不足道，但是它的性能足以让我们做一些小型的开发。</p>
<p>它的控制原理和pwm调速相似，但是它的周期是固定的。</p>
<p>舵机驱动的<strong>周期是20ms</strong>，<strong>占空比为0.5-2.5ms</strong>,也就是0-180度。</p>
<table>
<thead>
<tr>
<th>时间(ms)</th>
<th align="left">角度</th>
</tr>
</thead>
<tbody><tr>
<td>0.5</td>
<td align="left">0</td>
</tr>
<tr>
<td>1.0</td>
<td align="left">45</td>
</tr>
<tr>
<td>1.5</td>
<td align="left">90</td>
</tr>
<tr>
<td>2.0</td>
<td align="left">135</td>
</tr>
<tr>
<td>2.5</td>
<td align="left">180</td>
</tr>
</tbody></table>
<p>当然它的角度是线性变化的，并非固定只有5个角度。</p>
<h4 id="3、同时使用串口和定时器"><a href="#3、同时使用串口和定时器" class="headerlink" title="3、同时使用串口和定时器"></a>3、同时使用串口和定时器</h4><p>这里需要将<strong>TMOD</strong>改为<strong>0X21</strong></p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void TimeInit()&#x2F;&#x2F;定时器和串口同时初始化</span><br><span class="line">&#123;</span><br><span class="line">	SCON&#x3D;0X50;		</span><br><span class="line">	TMOD|&#x3D;0X21;		</span><br><span class="line">	PCON&#x3D;0X80;			</span><br><span class="line">	TH1 &#x3D; 0xF3;</span><br><span class="line">    TL1 &#x3D; TH1;</span><br><span class="line">    TR1&#x3D;1;	</span><br><span class="line">    TH0 &#x3D; 0x0FF;</span><br><span class="line">    TL0 &#x3D; 0x9C;</span><br><span class="line">    ET0 &#x3D; 1;</span><br><span class="line">    TR0 &#x3D; 1;</span><br><span class="line">	ES&#x3D;1;					</span><br><span class="line">	EA&#x3D;1;						</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、超声波避障等"><a href="#4、超声波避障等" class="headerlink" title="4、超声波避障等"></a>4、超声波避障等</h4><p>可以看本站关于超声波的文章</p>
<p>超声波模块HC-SR04四针通用延时驱动:<br><a href="https://square0097.github.io/2020/02/18/HC-SR04/" target="_blank" rel="noopener">https://square0097.github.io/2020/02/18/HC-SR04/</a></p>
<p>超声可以实现避障和倒车自停功能。</p>
<h4 id="5、常见故障问题解决"><a href="#5、常见故障问题解决" class="headerlink" title="5、常见故障问题解决"></a>5、常见故障问题解决</h4><h5 id="1-在进行停车或起步等一些动作时，出现重启现象"><a href="#1-在进行停车或起步等一些动作时，出现重启现象" class="headerlink" title="1.在进行停车或起步等一些动作时，出现重启现象**"></a>1.在进行停车或起步等一些动作时，出现重启现象**</h5><p>这里是因为电机在启动或停止瞬间电流消耗过大，引起的单片机电流不足断电，导致重启。</p>
<p><strong>解决方法</strong>：在单片机的VCC和GND之间加一个电容即可，容值越大效果越好。</p>
<h5 id="2-舵机运行时导致重启"><a href="#2-舵机运行时导致重启" class="headerlink" title="2.舵机运行时导致重启"></a>2.舵机运行时导致重启</h5><p>同样是耗电的原因，舵机的耗电相比电机要高，所以这里建议单独为舵机供电。</p>
<p><strong>解决办法</strong>：外加3.7V电池为舵机供电，注意共地。</p>
<h3 id="六、END"><a href="#六、END" class="headerlink" title="六、END"></a>六、END</h3><p>暂时就总结这么多，希望能对大家有所帮助！</p>
]]></content>
  </entry>
  <entry>
    <title>Jlink修复更换低版本驱动与龙邱20针转接10针下载</title>
    <url>/2020/02/19/Jlink/</url>
    <content><![CDATA[<h2 id="开始学习龙邱K60，但是没有能直接下载的Jlink，有个Jlink还是不好使的怎么办？"><a href="#开始学习龙邱K60，但是没有能直接下载的Jlink，有个Jlink还是不好使的怎么办？" class="headerlink" title="开始学习龙邱K60，但是没有能直接下载的Jlink，有个Jlink还是不好使的怎么办？"></a>开始学习龙邱K60，但是没有能直接下载的Jlink，有个Jlink还是不好使的怎么办？</h2><p>本篇主要记录如何修复Jlink，以及龙邱K60如何使用20针转接<br><img src="http://q5y0th4yi.bkt.clouddn.com/jlink001.jpg" alt></p>
<a id="more"></a>
<h3 id="一、如何修复Jlink"><a href="#一、如何修复Jlink" class="headerlink" title="一、如何修复Jlink"></a>一、如何修复Jlink</h3><p>一般情况下可能是固件丢失，我们可以尝试重新刷写固件，如果设备管理器仍然识别不了，那就可能是硬件问题。</p>
<h4 id="1-下载和安装烧录软件"><a href="#1-下载和安装烧录软件" class="headerlink" title="1.下载和安装烧录软件"></a>1.下载和安装烧录软件</h4><p>链接：<a href="https://pan.baidu.com/s/1GnowM-hvnPJJ6nIFYQleFA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GnowM-hvnPJJ6nIFYQleFA</a><br>提取码：klzs</p>
<p>内含烧录软件以及V8固件<br>直接安装<br><strong>sam-ba-2.12.exe</strong></p>
<h4 id="2-Jlink硬件复位"><a href="#2-Jlink硬件复位" class="headerlink" title="2.Jlink硬件复位"></a>2.Jlink硬件复位</h4><p>拆开Jlink，就可以看到 <strong>EREASE</strong> 和 <strong>TST</strong> 等标识的接口</p>
<ul>
<li>首先连接<strong>USB</strong></li>
<li>短接<strong>EREASE</strong>子祥处接口10秒以上</li>
<li>断开<strong>EREASE</strong>短接后再断开<strong>USB</strong></li>
<li>短接<strong>TST</strong>处接口</li>
<li>连接<strong>USB</strong>约20秒</li>
<li>断开<strong>USB</strong>再断开短接</li>
</ul>
<h4 id="3-刷写新的固件"><a href="#3-刷写新的固件" class="headerlink" title="3.刷写新的固件"></a>3.刷写新的固件</h4><ul>
<li><p>连接<strong>USB</strong>,打开<strong>sam-ba.exe</strong>，可以看到有设备连接，点击<strong>Connect</strong>,如果没有<strong>Connect</strong>怎么办，可以往下拉一下窗口，可能是被挡住了<br><img src="http://q5y0th4yi.bkt.clouddn.com/jlink002.JPG" alt></p>
</li>
<li><p>选择<strong>Send File Name</strong>,找到文件中的V8固件，并点击<strong>Send File</strong><br><img src="http://q5y0th4yi.bkt.clouddn.com/jlink003.JPG" alt></p>
</li>
<li><p>下面会出现两次询问窗口，第一次是是否解锁，我们选择<strong>Yes</strong>，第二次是是否锁定，我们选择<strong>No</strong><br><img src="http://q5y0th4yi.bkt.clouddn.com/jlink004.JPG" alt><br>这一套操作下来V8固件重刷就完成了</p>
</li>
</ul>
<h4 id="4-Keil5无法使用此Jlink"><a href="#4-Keil5无法使用此Jlink" class="headerlink" title="4.Keil5无法使用此Jlink"></a>4.Keil5无法使用此Jlink</h4><p>Keil5默认的Jlink驱动是很高版本的，我们需要替换成低版本的Jlink驱动。</p>
<p>官网下载<a href="https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack" target="_blank" rel="noopener">https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack</a></p>
<p>建议下载Jlink_V490</p>
<p>下载后找到</p>
<ul>
<li><strong>JFink.exe</strong></li>
<li><strong>JlinkARM.dll</strong></li>
<li><strong>JlinkRDI.dll</strong></li>
</ul>
<p>复制到<strong>keil5/ARM/Segger</strong>替换原文件</p>
<p>完成后发现Jlink已经可以正常使用</p>
<h3 id="二、龙邱K60如何转接"><a href="#二、龙邱K60如何转接" class="headerlink" title="二、龙邱K60如何转接"></a>二、龙邱K60如何转接</h3><p>看图，按照途中管脚接线<br><img src="http://q5y0th4yi.bkt.clouddn.com/jlink005.png" alt><br>这里<strong>RST</strong>接<strong>TRST_N</strong>即可</p>
<p>我在Jlink内部连接好了下载线，在外壳上扣了一个洞方便插线<br><img src="http://q5y0th4yi.bkt.clouddn.com/jlink006.jpg" alt></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>K60有发烫的毛病的时候千万不可一直插着电源</p>
]]></content>
  </entry>
  <entry>
    <title>OpenMV与单片机串口通信问题</title>
    <url>/2020/02/19/Openmvstm32/</url>
    <content><![CDATA[<h2 id="之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码"><a href="#之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码" class="headerlink" title="之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码"></a>之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码</h2><p>本文记录了其串口通信的方法<br><img src="http://q5y0th4yi.bkt.clouddn.com/Openmv-stm32001.jpg" alt></p>
<a id="more"></a>

<h2 id="OpenMV串口通信"><a href="#OpenMV串口通信" class="headerlink" title="OpenMV串口通信"></a>OpenMV串口通信</h2><p>openmv的管脚为数不多，我们要想做到控制更多的模块就要将他作为一个图像处理的传感器，把信息传输给我们用的其他芯片。<br><img src="http://q5y0th4yi.bkt.clouddn.com/Openmv-stm32002.jpg" alt></p>
<h3 id="1-串口管脚"><a href="#1-串口管脚" class="headerlink" title="1.串口管脚"></a>1.串口管脚</h3><p><strong>P4 TXD</strong></p>
<p><strong>P5 RXD</strong></p>
<h3 id="2-串口初始化"><a href="#2-串口初始化" class="headerlink" title="2.串口初始化"></a>2.串口初始化</h3><p>python下的代码很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time, pyb</span><br><span class="line">from pyb import UART</span><br><span class="line"></span><br><span class="line">uart &#x3D; UART(3, 115200, timeout_char&#x3D;1000)</span><br><span class="line"></span><br><span class="line">led_blue &#x3D; pyb.LED(3)&#x2F;&#x2F;这是自带的led，可以作为指示灯使用</span><br><span class="line">led_red &#x3D; pyb.LED(2)</span><br></pre></td></tr></table></figure>
<h3 id="3-串口发送"><a href="#3-串口发送" class="headerlink" title="3.串口发送"></a>3.串口发送</h3><p>普通发送字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uart.write(str)&#x2F;&#x2F;发送str字符串</span><br><span class="line">uart.write(&quot;abc&quot;)&#x2F;&#x2F;发送abc</span><br></pre></td></tr></table></figure>
<p>发送整形数就要用到json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;123</span><br><span class="line">y&#x3D;234</span><br><span class="line">str&#x3D;&#39;横坐标为&#39;+json.dumps(x)+&#39;纵坐标为&#39;+json.dumps(y)</span><br><span class="line">uart.write(str)</span><br></pre></td></tr></table></figure>
<h3 id="4、串口接收"><a href="#4、串口接收" class="headerlink" title="4、串口接收"></a>4、串口接收</h3><p>例如利用串口控制两个小led</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if uart.any():</span><br><span class="line">        a&#x3D;uart.readline().decode()</span><br><span class="line">        print(a)&#x2F;&#x2F;打印到终端</span><br><span class="line">        if a&#x3D;&#x3D;&#39;abc&#39;:</span><br><span class="line">            led_blue.on()</span><br><span class="line">            led_red.off()</span><br><span class="line">        if a&#x3D;&#x3D;&#39;abd&#39;:</span><br><span class="line">            led_blue.off()</span><br><span class="line">            led_red.on()</span><br></pre></td></tr></table></figure>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>注意，供电不得使用3.3V接口</p>
]]></content>
  </entry>
  <entry>
    <title>超声波模块HC-SR04四针通用延时驱动</title>
    <url>/2020/02/18/HC-SR04/</url>
    <content><![CDATA[<h2 id="对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？"><a href="#对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？" class="headerlink" title="对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？"></a>对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？</h2><p>本文意在让初学者学会使用超声波模块<br><img src="http://q5y0th4yi.bkt.clouddn.com/HC-SR04001.jpg" alt></p>
<a id="more"></a>

<h2 id="一、模块简介"><a href="#一、模块简介" class="headerlink" title="一、模块简介"></a>一、模块简介</h2><p>超声波模块我们在很多领域都能得到应用<br><img src="http://q5y0th4yi.bkt.clouddn.com/HC-SR04002.jpg" alt><br>HC-SR04模块使用很简单，我们使用它来制作一些小设备完全足够。<br>我们一般的思路就是使用定时器，这样是非常准确的。</p>
<h3 id="1-基本参数"><a href="#1-基本参数" class="headerlink" title="1.基本参数"></a>1.基本参数</h3><ul>
<li>使用电压：DC—5V   </li>
<li>静态电流：小于2mA       </li>
<li>电平输出：高5V     </li>
<li>电平输出：底0V         </li>
<li>感应角度：不大于15度    </li>
<li>探测距离：2cm-450cm </li>
<li>测量精度：可达0.2cm   <h3 id="2-时序"><a href="#2-时序" class="headerlink" title="2.时序"></a>2.时序</h3><img src="http://q5y0th4yi.bkt.clouddn.com/HC-SR04003.png" alt><h3 id="3-管脚"><a href="#3-管脚" class="headerlink" title="3.管脚"></a>3.管脚</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="center">管脚</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">VCC</td>
<td align="center">5V电源接口</td>
</tr>
<tr>
<td align="center">GND</td>
<td align="center">接地</td>
</tr>
<tr>
<td align="center">Echo</td>
<td align="center">信号输出</td>
</tr>
<tr>
<td align="center">Trig</td>
<td align="center">信号输入</td>
</tr>
</tbody></table>
<h2 id="二、驱动思路"><a href="#二、驱动思路" class="headerlink" title="二、驱动思路"></a>二、驱动思路</h2><p>简单的来说，就说我们只需要掌握</p>
<ul>
<li>如何触发模块</li>
<li>触发后如何获取信息<h3 id="1-触发"><a href="#1-触发" class="headerlink" title="1.触发"></a>1.触发</h3>从时序中可以看到，Trig信号输入引脚只需要给10us高电平，就能够触发模块工作<h3 id="2-接收"><a href="#2-接收" class="headerlink" title="2.接收"></a>2.接收</h3>我们只需要等待Echo管脚的高电平，并从记录下高电平的时间即可。<h3 id="3-计算"><a href="#3-计算" class="headerlink" title="3.计算"></a>3.计算</h3>公式：距离=高电平时间*声速(340M/S)/2。</li>
</ul>
<h2 id="三、51代码函数"><a href="#三、51代码函数" class="headerlink" title="三、51代码函数"></a>三、51代码函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void delay10us(void)   &#x2F;&#x2F;误差 0us</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a,b;</span><br><span class="line">    for(b&#x3D;1;b&gt;0;b--)</span><br><span class="line">        for(a&#x3D;1;a&gt;0;a--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float count()&#x2F;&#x2F;超声波函数</span><br><span class="line">&#123;</span><br><span class="line">	int s&#x3D;0,n;</span><br><span class="line">    float distance;</span><br><span class="line">	Trig&#x3D;1;&#x2F;&#x2F;触发引脚拉高</span><br><span class="line">	delay10us();</span><br><span class="line">	Trig&#x3D;0;&#x2F;&#x2F;触发引脚拉低</span><br><span class="line">	while(Echo!&#x3D;1)&#x2F;&#x2F;等待响应</span><br><span class="line">    &#123;</span><br><span class="line">  		delay10us();</span><br><span class="line">        n++;</span><br><span class="line">        if(n&#x3D;&#x3D;2000)&#x2F;&#x2F;超出响应时间</span><br><span class="line">        	return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	while(Exho&#x3D;&#x3D;1)&#x2F;&#x2F;得到响应</span><br><span class="line">	&#123;</span><br><span class="line">		 delay10us();</span><br><span class="line">		 s++;&#x2F;&#x2F;计数</span><br><span class="line">	&#125;</span><br><span class="line">    distance&#x3D;s*0.0034;</span><br><span class="line">	return distance;&#x2F;&#x2F;返回值为cm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么使用10us延时，可能大家会有疑问，这个是取决于机器周期的，不能生成1us的延时函数。</p>
<h2 id="四、END"><a href="#四、END" class="headerlink" title="四、END"></a>四、END</h2><p>延时看起来比较简单，但是实际上却有着一定误差，如果可以使用定时器那是最好的。</p>
<p>相信看完这个时序就能理解超声波模块的驱动方法了，<br>定时器驱动大同小异。</p>
]]></content>
  </entry>
  <entry>
    <title>AT89C51RC/RD系列贴片与P4管脚的使用</title>
    <url>/2020/02/18/AT89C52/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽然51系列性能相比stm32系列简直是很鸡肋，但是考虑到成本和使用简单的问题，在开发较小的不需要复杂功能的设备上，个人比较倾向于使用51的贴片。<br><img src="http://q5y0th4yi.bkt.clouddn.com/at89c52001.jpg" alt></p>
<a id="more"></a>

<h4 id="为啥突然想弄这个了呢"><a href="#为啥突然想弄这个了呢" class="headerlink" title="为啥突然想弄这个了呢"></a>为啥突然想弄这个了呢</h4><p>疫情发展得很迅速，快递全都躺在路上了，补番补得头疼，手头也没什么东西能玩的。看到在路上的51贴片里有P4这个管脚，但是我们51标准的头文件里没有P4管脚的相关定义，于是在家无聊的时间里研究了一下51贴片系列如何使用P4管脚。</p>
<h2 id="一、AT89C51RC-RD系列贴片封装"><a href="#一、AT89C51RC-RD系列贴片封装" class="headerlink" title="一、AT89C51RC/RD系列贴片封装"></a>一、AT89C51RC/RD系列贴片封装</h2><p>首先我们来看一下他的尺寸，因为毕竟是贴片要打PCB板的，我也是在网上找了很久才找到弄好的封装，不然就要自己手画了。</p>
<h3 id="1-尺寸"><a href="#1-尺寸" class="headerlink" title="1.尺寸"></a>1.尺寸</h3><p><img src="http://q5y0th4yi.bkt.clouddn.com/at89c52002.png" alt><br>这是官方文件里51贴片的尺寸图，用来参考整体尺寸还可以，个人觉得管脚尺寸有一些出入。<br>我这里有弄好的51贴片AD封装，需要的加我QQ。</p>
<h3 id="2-管脚"><a href="#2-管脚" class="headerlink" title="2.管脚"></a>2.管脚</h3><p><img src="http://q5y0th4yi.bkt.clouddn.com/at89c52003.png" alt></p>
<p>官方文档里给出的管脚图，我在网上找到的封装里是没有写P4管脚的，写的都是NC，所以要是想使用P4管脚就看这个管脚图吧。</p>
<h2 id="二、P4管脚的功能"><a href="#二、P4管脚的功能" class="headerlink" title="二、P4管脚的功能"></a>二、P4管脚的功能</h2><p>同样我们还是在官方文档里找，我找了半天，文件页数太多了…<br>其他管脚的功能和直插版的普通芯片是一样的。</p>
<table>
<thead>
<tr>
<th>管脚</th>
<th align="center">编号</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>P4.0</td>
<td align="center">17</td>
<td align="center">标准I/O口 PORT4[0]</td>
</tr>
<tr>
<td>P4.1</td>
<td align="center">28</td>
<td align="center">标准I/O口 PORT4[1]</td>
</tr>
<tr>
<td>P4.2 / INT3</td>
<td align="center">39</td>
<td align="center">标准I/O口 PORT4[2]；外部中断3，低电平或下降沿中断</td>
</tr>
<tr>
<td>P4.3 / INT2</td>
<td align="center">6</td>
<td align="center">标准I/O口 PORT4[3]；外部中断2，低电平或下降沿中断</td>
</tr>
<tr>
<td>P4.4 / PSEN</td>
<td align="center">26</td>
<td align="center">标准I/O口 PORT4[4]；外部程序储存器选通信号输出引脚</td>
</tr>
<tr>
<td>P4.5 / ALE</td>
<td align="center">27</td>
<td align="center">标准I/O口 PORT4[5]；地址锁存允许信号输出引脚/编程脉冲输入引脚</td>
</tr>
<tr>
<td>P4.6 / EA</td>
<td align="center">29</td>
<td align="center">标准I/O口 PORT4[6]；内外存储器选择引脚</td>
</tr>
</tbody></table>
<p>其实直插芯片里也引出了P4管脚，我们只是不知道哈哈哈</p>
<h2 id="三、如何使用P4管脚"><a href="#三、如何使用P4管脚" class="headerlink" title="三、如何使用P4管脚"></a>三、如何使用P4管脚</h2><p>为了使用P4我们首先要在标准头文件中添加P4的地址</p>
<p>在开头位置找到管脚定义   BYTE Registers<br>可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*  BYTE Registers  *&#x2F;</span><br><span class="line">sfr P0    &#x3D; 0x80;</span><br><span class="line">sfr P1    &#x3D; 0x90;</span><br><span class="line">sfr P2    &#x3D; 0xA0;</span><br><span class="line">sfr P3    &#x3D; 0xB0;</span><br><span class="line">sfr P4    &#x3D; 0xE8;&#x2F;&#x2F;后加的</span><br><span class="line">sfr PSW   &#x3D; 0xD0;</span><br><span class="line">sfr ACC   &#x3D; 0xE0;</span><br><span class="line">sfr B     &#x3D; 0xF0;</span><br><span class="line">sfr SP    &#x3D; 0x81;</span><br><span class="line">sfr DPL   &#x3D; 0x82;</span><br><span class="line">sfr DPH   &#x3D; 0x83;</span><br><span class="line">sfr PCON  &#x3D; 0x87;</span><br><span class="line">sfr TCON  &#x3D; 0x88;</span><br><span class="line">sfr TMOD  &#x3D; 0x89;</span><br><span class="line">sfr TL0   &#x3D; 0x8A;</span><br><span class="line">sfr TL1   &#x3D; 0x8B;</span><br><span class="line">sfr TH0   &#x3D; 0x8C;</span><br><span class="line">sfr TH1   &#x3D; 0x8D;</span><br><span class="line">sfr IE    &#x3D; 0xA8;</span><br><span class="line">sfr IP    &#x3D; 0xB8;</span><br><span class="line">sfr SCON  &#x3D; 0x98;</span><br><span class="line">sfr SBUF  &#x3D; 0x99;</span><br></pre></td></tr></table></figure>
<p>P4管脚加进来就好了,如果没有看文档的话可能就定义0xC0了…，8，9，A,B,C刚刚好是不是。</p>
<p>但是，官方文档中写了P4是0xE8！！！</p>
<h2 id="四、END"><a href="#四、END" class="headerlink" title="四、END"></a>四、END</h2><p>希望各位大佬们熬过疫情&lt;(▰˘◡˘▰)&gt;<br>有问题可以联系我哦</p>
]]></content>
  </entry>
</search>
