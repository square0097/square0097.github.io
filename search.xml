<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Jlink修复更换低版本驱动与龙邱20针转接10针下载</title>
    <url>/2020/02/19/Jlink/</url>
    <content><![CDATA[<h2 id="开始学习龙邱K60，但是没有能直接下载的Jlink，有个Jlink还是不好使的怎么办？"><a href="#开始学习龙邱K60，但是没有能直接下载的Jlink，有个Jlink还是不好使的怎么办？" class="headerlink" title="开始学习龙邱K60，但是没有能直接下载的Jlink，有个Jlink还是不好使的怎么办？"></a>开始学习龙邱K60，但是没有能直接下载的Jlink，有个Jlink还是不好使的怎么办？</h2><p>本篇主要记录如何修复Jlink，以及龙邱K60如何使用20针转接<br><img src="/2020/02/19/Jlink/thumb-1920-256566.jpg" alt></p>
<a id="more"></a>
<h3 id="一、如何修复Jlink"><a href="#一、如何修复Jlink" class="headerlink" title="一、如何修复Jlink"></a>一、如何修复Jlink</h3><p>一般情况下可能是固件丢失，我们可以尝试重新刷写固件，如果设备管理器仍然识别不了，那就可能是硬件问题。</p>
<h4 id="1-下载和安装烧录软件"><a href="#1-下载和安装烧录软件" class="headerlink" title="1.下载和安装烧录软件"></a>1.下载和安装烧录软件</h4><p>链接：<a href="https://pan.baidu.com/s/1GnowM-hvnPJJ6nIFYQleFA" target="_blank" rel="noopener">https://pan.baidu.com/s/1GnowM-hvnPJJ6nIFYQleFA</a><br>提取码：klzs</p>
<p>内含烧录软件以及V8固件<br>直接安装<br><strong>sam-ba-2.12.exe</strong></p>
<h4 id="2-Jlink硬件复位"><a href="#2-Jlink硬件复位" class="headerlink" title="2.Jlink硬件复位"></a>2.Jlink硬件复位</h4><p>拆开Jlink，就可以看到 <strong>EREASE</strong> 和 <strong>TST</strong> 等标识的接口</p>
<ul>
<li>首先连接<strong>USB</strong></li>
<li>短接<strong>EREASE</strong>子祥处接口10秒以上</li>
<li>断开<strong>EREASE</strong>短接后再断开<strong>USB</strong></li>
<li>短接<strong>TST</strong>处接口</li>
<li>连接<strong>USB</strong>约20秒</li>
<li>断开<strong>USB</strong>再断开短接</li>
</ul>
<h4 id="3-刷写新的固件"><a href="#3-刷写新的固件" class="headerlink" title="3.刷写新的固件"></a>3.刷写新的固件</h4><ul>
<li><p>连接<strong>USB</strong>,打开<strong>sam-ba.exe</strong>，可以看到有设备连接，点击<strong>Connect</strong>,如果没有<strong>Connect</strong>怎么办，可以往下拉一下窗口，可能是被挡住了<br><img src="/2020/02/19/Jlink/83284792479.JPG" alt></p>
</li>
<li><p>选择<strong>Send File Name</strong>,找到文件中的V8固件，并点击<strong>Send File</strong><br><img src="/2020/02/19/Jlink/347829187492.JPG" alt></p>
</li>
<li><p>下面会出现两次询问窗口，第一次是是否解锁，我们选择<strong>Yes</strong>，第二次是是否锁定，我们选择<strong>No</strong><br><img src="/2020/02/19/Jlink/221343243524.JPG" alt><br>这一套操作下来V8固件重刷就完成了</p>
</li>
</ul>
<h4 id="4-Keil5无法使用此Jlink"><a href="#4-Keil5无法使用此Jlink" class="headerlink" title="4.Keil5无法使用此Jlink"></a>4.Keil5无法使用此Jlink</h4><p>Keil5默认的Jlink驱动是很高版本的，我们需要替换成低版本的Jlink驱动。</p>
<p>官网下载<a href="https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack" target="_blank" rel="noopener">https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack</a></p>
<p>建议下载Jlink_V490</p>
<p>下载后找到</p>
<ul>
<li><strong>JFink.exe</strong></li>
<li><strong>JlinkARM.dll</strong></li>
<li><strong>JlinkRDI.dll</strong></li>
</ul>
<p>复制到<strong>keil5/ARM/Segger</strong>替换原文件</p>
<p>完成后发现Jlink已经可以正常使用</p>
<h3 id="二、龙邱K60如何转接"><a href="#二、龙邱K60如何转接" class="headerlink" title="二、龙邱K60如何转接"></a>二、龙邱K60如何转接</h3><p>看图，按照途中管脚接线<br><img src="/2020/02/19/Jlink/%5B1C11A386NP4WV%5D%5BFF1365F.png" alt><br>这里<strong>RST</strong>接<strong>TRST_N</strong>即可</p>
<p>我在Jlink内部连接好了下载线，在外壳上扣了一个洞方便插线<br><img src="/2020/02/19/Jlink/FA219BF1DF79BDF3F2E3CEF612B278F0.jpg" alt></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>K60有发烫的毛病的时候千万不可一直插着电源</p>
]]></content>
  </entry>
  <entry>
    <title>OpenMV与单片机串口通信问题</title>
    <url>/2020/02/19/Openmv-stm32/</url>
    <content><![CDATA[<h2 id="之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码"><a href="#之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码" class="headerlink" title="之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码"></a>之前在做OpenMV串口通信的时候遇到了一些坑，整形数据没有使用json字符串出现了乱码</h2><p>本文记录了其串口通信的方法<br><img src="/2020/02/19/Openmv-stm32/20190423133929_vpytt.jpg" alt></p>
<a id="more"></a>

<h2 id="OpenMV串口通信"><a href="#OpenMV串口通信" class="headerlink" title="OpenMV串口通信"></a>OpenMV串口通信</h2><p>openmv的管脚为数不多，我们要想做到控制更多的模块就要将他作为一个图像处理的传感器，把信息传输给我们用的其他芯片。<br><img src="/2020/02/19/Openmv-stm32/7a2ca28c-01e3-11e9-bf67-00163e2e672a.jpg_t590.jpg" alt></p>
<h3 id="1-串口管脚"><a href="#1-串口管脚" class="headerlink" title="1.串口管脚"></a>1.串口管脚</h3><p><strong>P4 TXD</strong></p>
<p><strong>P5 RXD</strong></p>
<h3 id="2-串口初始化"><a href="#2-串口初始化" class="headerlink" title="2.串口初始化"></a>2.串口初始化</h3><p>python下的代码很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time, pyb</span><br><span class="line">from pyb import UART</span><br><span class="line"></span><br><span class="line">uart &#x3D; UART(3, 115200, timeout_char&#x3D;1000)</span><br><span class="line"></span><br><span class="line">led_blue &#x3D; pyb.LED(3)&#x2F;&#x2F;这是自带的led，可以作为指示灯使用</span><br><span class="line">led_red &#x3D; pyb.LED(2)</span><br></pre></td></tr></table></figure>
<h3 id="3-串口发送"><a href="#3-串口发送" class="headerlink" title="3.串口发送"></a>3.串口发送</h3><p>普通发送字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uart.write(str)&#x2F;&#x2F;发送str字符串</span><br><span class="line">uart.write(&quot;abc&quot;)&#x2F;&#x2F;发送abc</span><br></pre></td></tr></table></figure>
<p>发送整形数就要用到json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;123</span><br><span class="line">y&#x3D;234</span><br><span class="line">str&#x3D;&#39;横坐标为&#39;+json.dumps(x)+&#39;纵坐标为&#39;+json.dumps(y)</span><br><span class="line">uart.write(str)</span><br></pre></td></tr></table></figure>
<h3 id="4、串口接收"><a href="#4、串口接收" class="headerlink" title="4、串口接收"></a>4、串口接收</h3><p>例如利用串口控制两个小led</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if uart.any():</span><br><span class="line">        a&#x3D;uart.readline().decode()</span><br><span class="line">        print(a)&#x2F;&#x2F;打印到终端</span><br><span class="line">        if a&#x3D;&#x3D;&#39;abc&#39;:</span><br><span class="line">            led_blue.on()</span><br><span class="line">            led_red.off()</span><br><span class="line">        if a&#x3D;&#x3D;&#39;abd&#39;:</span><br><span class="line">            led_blue.off()</span><br><span class="line">            led_red.on()</span><br></pre></td></tr></table></figure>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>注意，供电不得使用3.3V接口</p>
]]></content>
  </entry>
  <entry>
    <title>超声波模块HC-SR04四针通用延时驱动</title>
    <url>/2020/02/18/HC-SR04/</url>
    <content><![CDATA[<h2 id="对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？"><a href="#对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？" class="headerlink" title="对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？"></a>对距离要求精度不高的情况下，如何使用延时函数来粗略的获取距离呢？</h2><p>本文意在让初学者学会使用超声波模块<br><img src="/2020/02/18/HC-SR04/20130713232223-1245345432.jpg" alt></p>
<a id="more"></a>

<h2 id="一、模块简介"><a href="#一、模块简介" class="headerlink" title="一、模块简介"></a>一、模块简介</h2><p>超声波模块我们在很多领域都能得到应用<br><img src="/2020/02/18/HC-SR04/Gu38529855829fdd1527ddf8071289C3d2.jpg" alt><br>HC-SR04模块使用很简单，我们使用它来制作一些小设备完全足够。<br>我们一般的思路就是使用定时器，这样是非常准确的。</p>
<h3 id="1-基本参数"><a href="#1-基本参数" class="headerlink" title="1.基本参数"></a>1.基本参数</h3><ul>
<li>使用电压：DC—5V   </li>
<li>静态电流：小于2mA       </li>
<li>电平输出：高5V     </li>
<li>电平输出：底0V         </li>
<li>感应角度：不大于15度    </li>
<li>探测距离：2cm-450cm </li>
<li>测量精度：可达0.2cm   <h3 id="2-时序"><a href="#2-时序" class="headerlink" title="2.时序"></a>2.时序</h3><img src="/2020/02/18/HC-SR04/sxt128493298.png" alt><h3 id="3-管脚"><a href="#3-管脚" class="headerlink" title="3.管脚"></a>3.管脚</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="center">管脚</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">VCC</td>
<td align="center">5V电源接口</td>
</tr>
<tr>
<td align="center">GND</td>
<td align="center">接地</td>
</tr>
<tr>
<td align="center">Echo</td>
<td align="center">信号输出</td>
</tr>
<tr>
<td align="center">Trig</td>
<td align="center">信号输入</td>
</tr>
</tbody></table>
<h2 id="二、驱动思路"><a href="#二、驱动思路" class="headerlink" title="二、驱动思路"></a>二、驱动思路</h2><p>简单的来说，就说我们只需要掌握</p>
<ul>
<li>如何触发模块</li>
<li>触发后如何获取信息<h3 id="1-触发"><a href="#1-触发" class="headerlink" title="1.触发"></a>1.触发</h3>从时序中可以看到，Trig信号输入引脚只需要给10us高电平，就能够触发模块工作<h3 id="2-接收"><a href="#2-接收" class="headerlink" title="2.接收"></a>2.接收</h3>我们只需要等待Echo管脚的高电平，并从记录下高电平的时间即可。<h3 id="3-计算"><a href="#3-计算" class="headerlink" title="3.计算"></a>3.计算</h3>公式：距离=高电平时间*声速(340M/S)/2。</li>
</ul>
<h2 id="三、51代码函数"><a href="#三、51代码函数" class="headerlink" title="三、51代码函数"></a>三、51代码函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void delay10us(void)   &#x2F;&#x2F;误差 0us</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a,b;</span><br><span class="line">    for(b&#x3D;1;b&gt;0;b--)</span><br><span class="line">        for(a&#x3D;1;a&gt;0;a--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float count()&#x2F;&#x2F;超声波函数</span><br><span class="line">&#123;</span><br><span class="line">	int s&#x3D;0,n;</span><br><span class="line">    float distance;</span><br><span class="line">	Trig&#x3D;1;&#x2F;&#x2F;触发引脚拉高</span><br><span class="line">	delay10us();</span><br><span class="line">	Trig&#x3D;0;&#x2F;&#x2F;触发引脚拉低</span><br><span class="line">	while(Echo!&#x3D;1)&#x2F;&#x2F;等待响应</span><br><span class="line">    &#123;</span><br><span class="line">  		delay10us();</span><br><span class="line">        n++;</span><br><span class="line">        if(n&#x3D;&#x3D;2000)&#x2F;&#x2F;超出响应时间</span><br><span class="line">        	return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	while(Exho&#x3D;&#x3D;1)&#x2F;&#x2F;得到响应</span><br><span class="line">	&#123;</span><br><span class="line">		 delay10us();</span><br><span class="line">		 s++;&#x2F;&#x2F;计数</span><br><span class="line">	&#125;</span><br><span class="line">    distance&#x3D;s*0.0034;</span><br><span class="line">	return distance;&#x2F;&#x2F;返回值为cm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么使用10us延时，可能大家会有疑问，这个是取决于机器周期的，不能生成1us的延时函数。</p>
<h2 id="四、END"><a href="#四、END" class="headerlink" title="四、END"></a>四、END</h2><p>延时看起来比较简单，但是实际上却有着一定误差，如果可以使用定时器那是最好的。</p>
<p>相信看完这个时序就能理解超声波模块的驱动方法了，<br>定时器驱动大同小异。</p>
]]></content>
  </entry>
  <entry>
    <title>AT89C51RC/RD系列贴片与P4管脚的使用</title>
    <url>/2020/02/18/AT89C52/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽然51系列性能相比stm32系列简直是很鸡肋，但是考虑到成本和使用简单的问题，在开发较小的不需要复杂功能的设备上，个人比较倾向于使用51的贴片。<br><img src="/2020/02/18/AT89C52/begin.jpg" alt></p>
<a id="more"></a>

<h4 id="为啥突然想弄这个了呢"><a href="#为啥突然想弄这个了呢" class="headerlink" title="为啥突然想弄这个了呢"></a>为啥突然想弄这个了呢</h4><p>疫情发展得很迅速，快递全都躺在路上了，补番补得头疼，手头也没什么东西能玩的。看到在路上的51贴片里有P4这个管脚，但是我们51标准的头文件里没有P4管脚的相关定义，于是在家无聊的时间里研究了一下51贴片系列如何使用P4管脚。</p>
<h2 id="一、AT89C51RC-RD系列贴片封装"><a href="#一、AT89C51RC-RD系列贴片封装" class="headerlink" title="一、AT89C51RC/RD系列贴片封装"></a>一、AT89C51RC/RD系列贴片封装</h2><p>首先我们来看一下他的尺寸，因为毕竟是贴片要打PCB板的，我也是在网上找了很久才找到弄好的封装，不然就要自己手画了。</p>
<h3 id="1-尺寸"><a href="#1-尺寸" class="headerlink" title="1.尺寸"></a>1.尺寸</h3><p><img src="/2020/02/18/AT89C52/size1.png" alt><br>这是官方文件里51贴片的尺寸图，用来参考整体尺寸还可以，个人觉得管脚尺寸有一些出入。<br>我这里有弄好的51贴片AD封装，需要的加我QQ。</p>
<h3 id="2-管脚"><a href="#2-管脚" class="headerlink" title="2.管脚"></a>2.管脚</h3><p><img src="/2020/02/18/AT89C52/51_ad3.png" alt></p>
<p>官方文档里给出的管脚图，我在网上找到的封装里是没有写P4管脚的，写的都是NC，所以要是想使用P4管脚就看这个管脚图吧。</p>
<h2 id="二、P4管脚的功能"><a href="#二、P4管脚的功能" class="headerlink" title="二、P4管脚的功能"></a>二、P4管脚的功能</h2><p>同样我们还是在官方文档里找，我找了半天，文件页数太多了…<br>其他管脚的功能和直插版的普通芯片是一样的。</p>
<table>
<thead>
<tr>
<th>管脚</th>
<th align="center">编号</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>P4.0</td>
<td align="center">17</td>
<td align="center">标准I/O口 PORT4[0]</td>
</tr>
<tr>
<td>P4.1</td>
<td align="center">28</td>
<td align="center">标准I/O口 PORT4[1]</td>
</tr>
<tr>
<td>P4.2 / INT3</td>
<td align="center">39</td>
<td align="center">标准I/O口 PORT4[2]；外部中断3，低电平或下降沿中断</td>
</tr>
<tr>
<td>P4.3 / INT2</td>
<td align="center">6</td>
<td align="center">标准I/O口 PORT4[3]；外部中断2，低电平或下降沿中断</td>
</tr>
<tr>
<td>P4.4 / PSEN</td>
<td align="center">26</td>
<td align="center">标准I/O口 PORT4[4]；外部程序储存器选通信号输出引脚</td>
</tr>
<tr>
<td>P4.5 / ALE</td>
<td align="center">27</td>
<td align="center">标准I/O口 PORT4[5]；地址锁存允许信号输出引脚/编程脉冲输入引脚</td>
</tr>
<tr>
<td>P4.6 / EA</td>
<td align="center">29</td>
<td align="center">标准I/O口 PORT4[6]；内外存储器选择引脚</td>
</tr>
</tbody></table>
<p>其实直插芯片里也引出了P4管脚，我们只是不知道哈哈哈</p>
<h2 id="三、如何使用P4管脚"><a href="#三、如何使用P4管脚" class="headerlink" title="三、如何使用P4管脚"></a>三、如何使用P4管脚</h2><p>为了使用P4我们首先要在标准头文件中添加P4的地址</p>
<p>在开头位置找到管脚定义   BYTE Registers<br>可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*  BYTE Registers  *&#x2F;</span><br><span class="line">sfr P0    &#x3D; 0x80;</span><br><span class="line">sfr P1    &#x3D; 0x90;</span><br><span class="line">sfr P2    &#x3D; 0xA0;</span><br><span class="line">sfr P3    &#x3D; 0xB0;</span><br><span class="line">sfr P4    &#x3D; 0xE8;&#x2F;&#x2F;后加的</span><br><span class="line">sfr PSW   &#x3D; 0xD0;</span><br><span class="line">sfr ACC   &#x3D; 0xE0;</span><br><span class="line">sfr B     &#x3D; 0xF0;</span><br><span class="line">sfr SP    &#x3D; 0x81;</span><br><span class="line">sfr DPL   &#x3D; 0x82;</span><br><span class="line">sfr DPH   &#x3D; 0x83;</span><br><span class="line">sfr PCON  &#x3D; 0x87;</span><br><span class="line">sfr TCON  &#x3D; 0x88;</span><br><span class="line">sfr TMOD  &#x3D; 0x89;</span><br><span class="line">sfr TL0   &#x3D; 0x8A;</span><br><span class="line">sfr TL1   &#x3D; 0x8B;</span><br><span class="line">sfr TH0   &#x3D; 0x8C;</span><br><span class="line">sfr TH1   &#x3D; 0x8D;</span><br><span class="line">sfr IE    &#x3D; 0xA8;</span><br><span class="line">sfr IP    &#x3D; 0xB8;</span><br><span class="line">sfr SCON  &#x3D; 0x98;</span><br><span class="line">sfr SBUF  &#x3D; 0x99;</span><br></pre></td></tr></table></figure>
<p>P4管脚加进来就好了,如果没有看文档的话可能就定义0xC0了…，8，9，A,B,C刚刚好是不是。</p>
<p>但是，官方文档中写了P4是0xE8！！！</p>
<h2 id="四、END"><a href="#四、END" class="headerlink" title="四、END"></a>四、END</h2><p>希望各位大佬们熬过疫情&lt;(▰˘◡˘▰)&gt;<br>有问题可以联系我哦</p>
]]></content>
  </entry>
</search>
